# Redis

## 概述

Redis，英文全称是Remote Dictionary Server（远程字典服务），是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。

与MySQL数据库不同的是，Redis的数据是存在内存中的。它的读写速度非常快，每秒可以处理超过10万次读写操作。因此redis被广泛应用于缓存，另外，Redis也经常用来做分布式锁。除此之外，Redis支持事务、持久化、LUA 脚本、LRU 驱动事件、多种集群方案。

## 基本命令

* dbsize 查询库中元素个数
* select *index* 选择指定的库, 范围: 0 -- 15
* auth *password* 输入密码
* ttl *key* 查询指定key的过期时间
* expire *key* *seconds* 指定一个key的过期时间
* exists *key* 判断一个key是否存在
* del *key1* *key2* ... 删除kv
* rename *key* *newkey* 重命名

## Redis中的数据类型

* 5种基本数据类型
  * String
  * Hash
  * List
  * Set
  * zset(有序集合)
* 3种特殊的数据类型
  * Geospatial
  * Hyperloglog
  * Bitmap

**String**

特点:

* 二进制安全, 可以存储图片或者序列化对象
* 值最大存储为512M

常用命令:

* set *key* *value*
* get *key*
* incr *key*
* decr *key*

应用场景: session共享, 分布式锁, 计数器, 限流

Redis使用SDS(simple dynamic string)封装, 并且3.2以上版本, 针对不同长度定义了不同的数据结构, 3.2下版本的大致结构如下:

```c
struct sdshdr{
    unsigned int len; // 标记buf总长度
    unsigned int free;  // 标记buf中未使用的元素个数
    char buf[];
}
```

redis之所以选择sds而不是使用c语言原生```char[]```是因为sds中, 可以在O(1)时间复杂度内, 就可以获取到字符串的长度, 而```char[]```则需要O(n).

**Hash**

Hash类型是指v本身又是一个键值对(k-v)结构

常用命令:

* hset *key* *field* *value*
* hget *key* *field*
* hgetall *key* (如果使用hgetall, 当hash元素较多时, 可能会造成Redis阻塞, 可以使用hscan. 如果只是获取部分field, 建议使用hmget)
* hmget *key* *field1* *field2* ...
* hscan *key* *cursor* [match *pattern*] [count *count*] (cursor是一个数字, 初始时, 输入0, 下一次输入上一次返回的值)

应用场景: 缓存用户信息等

**List**

列表(list)类型是用类存储多个有序的字符串, 一个列表最多可以存储2^32-1个元素

常用命令:

* lpush *key* *value1* *value2* ...
* lrange *key* *start* *end*
* rpush *key* *value1* *value2* ...
* lpop *key* [*count*]
* rpop *key* [*count*]

应用场景:

消息队列, 文章列表:

* 栈: lpush + lpop
* 队列: lpush + rpop
* 有限集合: lpsh + ltrim
* 消息队列: lpush + brpop

**Set**

用于保存多个的字符串元素, 不允许重复元素

常用命令:

* sadd *key* *element1* *element2* ...
* smembers *key*

应用场景: 用户标签, 生成随机数抽奖, 社交需求

> smembers, lrange, hgetall都属于较重的命令, 如果元素过多, 存在阻塞Redis的可能性, 对于smembers可以使用sscan来完成.

**zset**

已排序的字符串集合, 元素不能重复

常用命令:

* zadd *key* *score1* *member1* *score2* *member2* ...
* zrank *key* *member*

> score越小, 越靠前

应用场景: 排行榜, 社交需求(用户点赞等)

**三种特殊数据类型**

* Geo: 3.2推出的, 地理位置定位, 用于存储地理位置信息, 并对存储的信息进行操作
* HyperLogLog: 用来做基数统计算法的数据结构, 如统计网站的UV
* Bitmaps: 用一个比特位来映射某个元素的状态, 在Redis中, 它的底层是基于字符串类型实现的, 可以把bitmaps看做为一个以bit为单位的数组.

## Redis速度快的原因

1. 基于内存存储
2. 高效的数据结构
   * SDS简单动态字符串
     * 字符串长度处理: 获取字符串长度的时间复杂度为O(1), 而C语言中, 需要从头开始遍历, 复杂度为O(n)
     * 空间预分配: 字符串修改越频繁, 内存分配越频繁, 就会越消耗性能, 而SDS修改和空间扩充, 会额外分配未使用的空间, 减少性能损耗
     * 惰性空间释放: SDS缩短时, 不是回收多余的内存空间, 而是free记录下多余的空间, 后续有变更, 直接使用free中记录的空间, 减少分配
     * 二进制安全: Redis可以用来存储二进制数据, 在C语言中字符串遇到'\0'会结束, 而SDS中标志字符串结束的是len属性
   * 字典: 作为k-v数据库, 所有键值都是用字典来存储, 在O(1)时间复杂的就可以获得对应的值
   * 跳跃表: zset的底层实现, 就是在链表的基础上, 增加多级索引提升查找效率
3. 合理的数据编码: Redis支持多种数据类型, 每种类型可能对多种数据结构, 什么时候使用什么编码, 是redis设计者总结优化的结果
   * String: 数字-int; 小于等于39字节-embsttr; 大于39字节-raw编码
   * List: 如果列表的元素个数小于512个, 列表每个元素的值都小于64字节(默认), 使用ziplist(压缩列表), 否则使用linkedlist
   * Hash: 哈希类型元素个数小于512个, 所有值都小于64字节, 使用ziplist,否则使用hashtable
   * Set: 如果集合中元素都是整数且个数小于512个, 使用intset编码, 否则使用hashtable
   * Zset: 当有序集合的元素个数小于128个, 每个元素的值小于64字节, 使用ziplist, 否则使用skiplist(跳跃表)
4. 合理的线程模型
   * I/O多路复用(epoll), 多个连接复用同一个线程, 让单个线程更高效的处理多个连接请求.
   * 单线程模型: redis是单线程模型, 避免了CPU不必要的上下问切换和竞争锁消耗. 但是, 如果某个命令执行过长, 会造成阻塞.
     * redis6.0引入多线程提速, 但是执行命令操作内存仍然是单线程. 只是使用多线程来处理数据读写和协议解析. 因为redis性能瓶颈在于网络IO而非CPU, 使用多线程能提升IO读写效率, 从而提升redis性能
5. 虚拟内存机制
   * redis构建了自己的VM机制, 不会像一般的系统的会调用系统函数处理, 浪费时间去移动和请求
   * 虚拟内存机制是指: 把暂时不经常访问的数据(冷数据)从内存交换到磁盘中, 从而腾出宝贵的内存空间用于其他需要访问的数据(热数据). 通过VM功能可以实现冷热数据分离, 使热数据仍在内存中, 冷数据保存在磁盘. 这样就可以避免因为内存不足而造成访问速度下降的问题.

## 缓存击穿/缓存穿透/缓存雪崩

**缓存穿透**

* 定义: 指缓存和数据库中都没有数据, 而用户不断发送请求, 如发起id为"-1"或者id为特别大不存在的数据. 这时的用户很可能是攻击者, 攻击会导致数据库压力过大
* 解决方案:
 1. 接口层增加校验, 如用户权鉴, id做基础校验, id<=0直接拦截;
 2. 从缓存取不到数据, 在数据库中也取不到, 这时可以将key-value写为key-null, 缓存有效时间可以设置短点(设置太长会导致正常情况下也没法使用). 这样就可以防止攻击用户反复用同一个id暴力攻击
 3. 使用布隆过滤器, 快速判断数据是否存在. 即一个查询请求过来时, 先通过布隆过滤器判断值是否存在, 存在才继续往下查


**缓存击穿**

* 定义: 缓存击穿是指缓存中没有但是数据库中有数据(一般是缓存时间到期), 这时由于并发用户特别多, 同时读缓存没有读到数据, 有同时去数据库取数据, 引起数据库压力瞬间增大.
* 解决方案:
  1. 设置热点数据永远不过期
  2. 加互斥锁
  3. 其中一个线程请求新值, 其余线程暂时使用旧值

**缓存雪崩**

* 定义: 缓存雪崩是指缓存中数据大批量到期, 而查询数据量巨大, 引起数据库压力过大. 和缓存击穿不同的是, 缓存击穿是指并发查询同一条数据, 缓存雪崩是不同数据都过期了, 很多数据都查询不到从而查询数据库
* 解决方案:
   1. 缓存数据的过期时间设置随机, 防止同一时间大量数据过期现象发生
   2. 如果缓存数据库是分布式部署, 将热点数据均匀分布在不同缓存数据库中
   3. 设置热点数据永远不过期