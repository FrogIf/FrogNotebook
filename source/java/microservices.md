# 微服务

## 概述

微服务架构（通常简称为微服务）是指开发应用所用的一种架构形式。通过微服务，可将大型应用分解成多个独立的组件，其中每个组件都有各自的责任领域。在处理一个用户请求时，基于微服务的应用可能会调用许多内部微服务来共同生成其响应。

## 微服务架构下的安全认证与鉴权

传统单体应用认证和权鉴: 单体应用中, 应用是一个整体, 一般针对所有请求都会进行权限校验. 请求一般会通过一个权限拦截器进行权限校验, 在登录时将用户信息缓存到session中, 后续访问则从缓存中获取用户信息.

微服务架构下, 这种权鉴方式就不合适了, 主要有以下几方面问题:

1. 多个应用之间共享同一套用户信息;
2. 需要考虑场景: 1. 外部应用接入; 2. 用户-服务; 3. 服务-服务

针对这种场景, 有以下四种方案:

1. 单点登录(SSO): 每一个服务都需要与认证服务进行交互, 会产生大量琐碎的网络流量和重复的工作, 当动辄数十个微服务时, 这种方案的弊端明显;
2. 分布式 Session 方案: 分布式session主要是将用户认证信息存储在共享存储中, 且通常由sessionId作为key来实现简单的分布式hash映射. 当用户访问微服务时, 用户数据可以从共享存储中获取. 某些场景下, 这种方案很不错, 用户登录状态是不透明的. 同时也是一个高可用且可扩展的解决方案. 这种方案的缺点在于共享存储需要一定保护机制, 因此需要通过安全链接来访问, 这时解决方案的实现就通常具有相当高的复杂性.
3. 客户端koken方案: token在客户端生成, 由身份认证服务进行性签名, 必须包含足够的信息, 以便可以在所有微服务中建立用户身份. 令牌会附件到每个请求上, 为微服务提供用户身份验证, 这种解决方案安全性相对较好, 但是身份验证注销是一个大问题, 环节这种情况的方法可以使用短期令牌和频繁检查认证服务等. 对于客户端令牌的编码方案, 比较常见的是JWT(JSON Web Tokens), 它足够简单且库支持程度也较好.
4. 客户端token与API网关结合: 这个方案意味着所有请求都通过网关, 从而有效的隐藏了微服务. 在请求时, 网关将原始用户令牌作为内部会话ID令牌. 在这种情况下, 注销就不是问题, 因为网关可以在注销是撤销用户令牌.

常见安全认证方案:

#### session认证

session认证: 用户登录成功后, 将session存储在服务端, 将sessionId返回给客户端.

分布式架构中, 多个节点都有相同的session信息, 为了保证这点, 有三种方式:

1. session复制:  应用需要具备session复制的能力. 但是大量session复制会占用较多的网络资源. 
2. session粘滞:  session粘滞就是不做session共享. 通过负载均衡器, 将统一用户的请求分发到固定的服务器节点上, 这样就保证了对某一用户而言, session数据始终是正确的. 但是这种方案对负载均衡依赖较重, 并且无法满足水平扩展的场景.
3. session共享:  通过redis等将session做集中存储.

#### token认证

token是存储在客户端的, 它本身一般会包含一些用户信息, 通过验证token, 就可以完成身份身份校验. 典型流程如下:

1. 客户端使用用户名跟密码请求登录;
2. 服务端收到请求，去验证用户名与密码;
3. 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端;
4. 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里;
5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token;
6. 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据.

一般采用JWT的方式实现这个token, jwt由三部分组成:

* header -- 头部: 传给你在两部分信息: 声明类型, 这里是jwt; 声明加密算法, 通常直接使用HMACSHA256;
* payload -- 载荷段: 存放有效数据. 主要包含三部分: 标准中注册的声明; 公共的声明; 私有的声明.
* signature -- 签证: 又由三部分组成: encrypt(base64(header) + base64(payload), secret).

当客户端每次请求时, 都会携带jwt. 后台会通过私钥解密signature, 然后比对看这个解密后的signature与payload的内容是否一致, 如果一致, 验证通过. 解密的过程没有依赖数据库等组件, 减少了对服务器资源的依赖.

需要注意的:

* secret私钥是存储在服务端的, 并且不能对外暴露;
* jwt实现的token中不能存放敏感信息, 因为这个token是可以解密的; jwt的目的是认证, 不保证数据不泄露;
* 如何认证, signature部分在服务端使用secret解密后, 与token中的header和payload进行对比, 如果一致, 则认证成功. 可想而知, 如果私钥泄露出去, 客户端就可以自行签发生成token, 然后通过服务端的认证.

token注销:

* Token 存储在 Cookie 中，这样客户端注销时，自然可以清空掉.
* 手动注销时, 将 Token 存放到分布式缓存中，每次校验 Token 时去检查下该 Token 是否已注销。不过这样也就失去了快速校验Token的优点
* 多采用短期令牌，比如令牌有效期是 20 分钟，这样可以一定程度上降低注销后 Token 可用性的风险。

token存储在客户端, 服务端不会存储任何信息, 那么如何使得token在长时间没有访问的情况下, 自动失效呢?

可以在生成token的时候, 在payload中增加一个时间戳. 每次请求时, 服务端都会校验这个时间戳是否过期. 

那么, 又存在一个问题. 如果不主动修改时间戳的话, 即使用户一直在访问, 一段时间后, token也会过期的. 所以, 必须要有token续期机制. 可以有以下几种方案:

* 单token方案:
  1. 将token过期时间设置为15分钟;
  2. 前端发起请求, 后端验证token是否过期; 如果过期, 前端发起刷新token请求, 后端为前端返回一个新的token;
  3. 前端用新的token发起请求, 请求成功;

> 这里刷新token也是需要校验的, 如果老的token已经是几个小时之前的了, 就不能刷新了.
> 如果要实现每隔72小时，必须重新登录，后端需要记录每次用户的登录时间；用户每次请求时，检查用户最后一次登录日期，如超过72小时，则拒绝刷新token的请求，请求失败，跳转到登录页面。
> 另外后端还可以记录刷新token的次数，比如最多刷新50次，如果达到50次，则不再允许刷新，需要用户重新授权。


* 双token方案:
  1. 登录成功后, 后端返回access_token和refresh_token, 客户端缓存此两种token;
  2. 使用access_token请求接口资源成功, 则正常执行. 如果token超时, 客户端携带refresh_token调用token刷新接口获取新的access_token;
  3. 后端接收到刷新请求后, 检查refresh_token是否过期. 如果过期, 拒绝刷新, 客户端收到该状态后, 跳转至登录页; 如果未过期, 生成新的access_token返回给客户端;
  4. 客户端携带新的access_token重新调用上面的资源接口;
  5. 客户端退出登录或者修改密码后, 注销旧的token, 使access_token和refresh_token失效, 同时清空客户端的access_token和refresh_token;

> access_token的过期时间一般较短, 1-2个小时; refresh_token时间较长, 可以设置到30天.

> 后端实现token过期还可以通过redis来实现.

## Reference

* [微服务架构下的安全认证与鉴权](https://www.infoq.cn/article/uib7ark52myroa2kl7xf)