# Zookeeper

## 常用应用场景

Zookeeper是一个分布式的, 开放源码的分布式应用程序协调服务. 常见应用场景:

* 分布式配置管理: Zookeeper可以存储配置信息, 应用程序可以动态读取配置信息;
* 分布式同步: Zookeeper可以协调各个节点的同步, 确保数据的一致性;
* 命名服务: Zookeeper可以作为一个命名服务, 应用程序可以通过名字找到所需的服务;
* 集群管理: 管理分布式集群, 协调各个节点的加入和退出;
* Master选举: 可以用来实现Master选举, 选择一个节点作为Master节点;
* 分布式协调服务: 分布式锁, 唯一标识等;
* 服务注册和发现: 可以用于服务注册发现, 简化服务的部署和更新;
* 负载均衡: 可以用于动态的对请求进行负载均衡, 以提高系统的可用性;

> 它的职责是保证数据(配置数据/状态数据)在其管辖下的所有服务之间保持同步,一致. 它是一个CP的分布式系统(Consistency-一致性 + Partition tolerance-分区容错性). 所以它会牺牲可用性, 即在极端情况下丢弃一些请求, 消费者程序需要重新请求才能获取. 总体体现在如下:
> 1. 集群中存活节点数低于总结点数的一半, 整个集群将无法接受新的写请求;
> 2. 在ZK的master选举中, 在新的Master被选举出来之前, 这个集群也无法接受新的写请求;

## Zookeeper的数据结构

zk中的数据是以目录的形式存储的. 其中每个存储数据的节点都叫做Znode, 每个Znode都有一个唯一的路径标识. 和目录结构类似, 每一个节点都可以有子节点(临时节点除外). 节点中可以存储数据和状态信息, 每个Znode上可以配置监听器, 用于监听节点中的数据变化. 节点不支持部分读写, 而是一次性完整读写.

Znode有四种类型:

* PERSISTENT: 持久节点;
  * 在节点创建后, 就一直存在, 直到有删除操作来主动清除这个节点;
* PERSISTENT_SEQUENTIAL: 持久的连续节点;
  * 创建的节点时, 会自动给节点名加上一个数字后缀作为新的节点名, 范围是整型的最大值;
* EPHEMERAL: 临时节点;
  * 临时节点的生命周期和客户端会话绑定, 客户端会话失效, 那么这个节点就会自动被清除掉;
  * 临时节点不能有子节点;
* EPHEMERAL_SEQUENTIAL: 临时的连续节点;
  * 创建的节点会自动加上编号;

```java
String root = "/computer";
String createPath = zk.create(root, root.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
System.out.println("createPath = " + createPath);
for(int i = 0; i < 5; i++){
    String path = "/computer/node";
    String createPath = zk.create(root, root.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);
    System.out.println("createPath = " + createPath);
}
zk.close();
```
运行结果:
```
createPath = /computer
createPath = /computer/node0000000000
createPath = /computer/node0000000001
createPath = /computer/node0000000002
createPath = /computer/node0000000003
createPath = /computer/node0000000004
```

每个znode被创建时都会带有一个ACL列表, 用于决定谁可以对它执行何种操作.

watcher在Zookeeper是一个核心功能, Watcher可以监控目录节点的数据变化以及子目录变化, 一旦这些状态发生变化, 服务器就会通知所有设置在这个目录节点上的watcher, 从而每个客户端都很快知道它所关注的目录节点状态发生变化, 而做出相应的反应. 可以设置观察的操作: `exists`, `getChildren`, `getData`, 可以触发观察的操作: `create`, `delete`, `setData`

## 集群角色

* Leader(领导者): 负责进行投票的发起和决议, 更新系统状态. 为客户端提供读和写服务;
* Follower(跟随者): 用于接受客户端请求并响应客户端返回结果, 在选主过程中参与投票. 为客户端提供读服务;
* Observer(观察者): 可以接受客户端连接, 将写请求转发给leader, 但observer不参加投票过程, 只同步leader状态, observer的目的是为了扩展系统, 提高读取速度;
* Client(客户端): 请求发起方

## 服务的启动与停止

找到 %zkHome%\bin 目录, 通过该目录下的 zkServer.sh
* 启动 zkServer.sh start
* 停止 zkServer.sh stop
* 重启 zkServer.sh restart
* 查看ZK服务状态 zkServer.sh status

## zk客户端命令

ZooKeeper命令行工具类似于Linux的shell环境，不过功能肯定不及shell啦，但 是使用它我们可以简单的对ZooKeeper进行访问，数据创建，数据修改等操作.  使用 zkCli.sh -server 127.0.0.1:2181 连接到 ZooKeeper 服务，连接成功后，系统会输出 ZooKeeper 的相关环境以及配置信息。命令行工具的一些简单操作如下:

* 显示根目录下、文件： ls / 使用 ls 命令来查看当前 ZooKeeper 中所包含的内容
* 显示根目录下、文件： ls2 / 查看当前节点数据并能看到更新次数等数据
* 创建文件，并设置初始内容： create /zk "test" 创建一个新的 znode节点" zk "以及与它关联的字符串
* 获取文件内容： get /zk 确认 znode 是否包含我们所创建的字符串
* 修改文件内容： set /zk "zkbak" 对 zk 所关联的字符串进行设置
* 删除文件： delete /zk 将刚才创建的 znode 删除
* 退出客户端： quit
* 帮助命令： help

登录账号:
```
addauth digest user:password
```

## 内置的四字命令(方便且实用)

ZooKeeper 支持某些特定的四字命令字母与其的交互。它们大多是查询命令，用来获取 ZooKeeper 服务的当前状态及相关信息。用户在客户端可以通过 telnet 或 nc 向 ZooKeeper 提交相应的命令。nc的做法为 nc localhost 2181 + 回车 ，然后输入以下命令中的一个，则服务器会返回相应的信息

* stat 来查看哪个节点被选择作为follower或者leader
* ruok 测试是否启动了该Server，若回复imok表示已经启动
* dump ,列出未经处理的会话和临时节点
* kill ,关掉server
* conf ,输出相关服务配置的详细信息
* cons ,列出所有连接到服务器的客户端的完全的连接 / 会话的详细信息
* envi ,输出关于服务环境的详细信息（区别于 conf 命令）
* reqs ,列出未经处理的请求
* wchs ,列出服务器 watch 的详细信息
* wchc ,通过 session 列出服务器 watch 的详细信息，它的输出是一个与 watch 相关的会话的列表
* wchp ,通过路径列出服务器 watch 的详细信息。它输出一个与 session 相关的路径
* mntr ,输出一些ZK运行时信息，通过对这些返回结果的解析，可以达到监控的效果
* srst ,重置服务器的统计信息（功能性命令，慎用）
* crst ,重置所有连接的统计信息（功能性命令，慎用）

## 选举机制

1. 初始化阶段: 在一个Zookeeper集群中, 每个Follower节点都可以成为Leader节点. 初始状态下, 所有Follower节点都是处于"LOOKING"状态, 即寻找Leader. 每个节点都会监视集群中的其他节点, 以侦听Leader选举消息;
2. 提名和投票: 当一个节点启动时, 它会向其他节点发送投票请求, 称为提名. 节点收到提名后可以选择投票支持这个提名节点, 也可以不投票. 每个节点只能在一个选举周期内投出一票;
   * 提名过程中, 所有投票者都遵循一个原则: 遇强投强
   * 强弱的判断: 通过数据是否足够新来判断这个节点是不是够强. Zookeeper中以事务id(zxid)来标识数据的新旧程度, 节点的zxid越大表示数据越新, 节点能力越强.
   * 投票过程中, 节点首先会认为自己是最强的, 先投自己一票, 然后把投票信息广播出去, 这里包含zxid和sid, zxid就是自己的事务id, sid就是自己的唯一标识;
   * 集群中的节点就会不断收到别人发过来的投票结果, 然后这个节点就会拿别人的zxid和自己的zxid进行比较, 如果别人的更大, 说明他的数据更新, 那么就会重新投票, 把zxid和sid都换成别人的信息再发出去.
3. 选举过程: 选举过程分为多轮, 每轮称为一个"选举周期". 在每个选举周期中, 节点根据投票数来选择新的Leader候选者. 如果一个候选者获得了大多数节点(超过半数)的投票, 那么它就会成为新的Leader. 否则, 没有候选者获得足够的投票, 那么这个选举周期失败, 所有节点继续下一个选举周期.
4. Leader确认: 一旦一个候选者获得了大多数节点的投票, 它就会成为新的Leader. 这个Leader会向其他节点发送Leader就绪消息, 告知它们自己已经成为Leader, 并且开始处理客户端请求.
5. 集群同步: 一旦新的Leader选举完成, 其他节点会与新的Leader同步数据, 确保所有节点在一个一致的状态下运行. 这个同步过程也包括了未完成的客户端请求, 以保证数据的一致性.

## 脑裂

由于网络或者节点故障等原因, 导致一个分布式系统被分为多个独立的子系统, 每个子系统独立运行, 无法相互通信, 同时认为自己是整个系统的主节点, 这就导致整个系统失去一致性和可用性.

Zookeeper集群中脑裂出现的原因通常有以下两种情况:

* 网络分区: 当Zookeeper集群中的某些节点无法与其他节点通信时, 就会出现网络分区现象. 这时, 无法确定哪个节点是主节点, 容易导致多个主节点的情况;
* 主节点宕机: 当Zookeeper集群中的主节点宕机时, 其他节点可能会重新选举新的主节点. 如果宕机的主节点恢复后, 会与其他节点产生不一致, 可能导致脑裂.

脑裂恢复:

* 自动恢复机制: 脑裂后, Zookeeper会自动发现并尝试恢复. 当大多数节点恢复后, 会重新选举主节点, 并将状态同步给其他节点.
* 手动恢复

脑裂避免

* 设置合适的选举时间
* 设置合适的节点数量
* 通过Watch机制来监听节点状态变化, 及时发现并处理异常情况

## 实现分布式锁

基于Zookeeper临时有序节点(EPHEMERAL_SEQUENTIAL)可以实现分布式锁.

思路: 客户端对方法加锁时, zookeeper上的与该方法对应的指定节点目录下, 生成一个唯一的瞬时有序节点. 判断是否获取锁的方式很简单, 只需要判断有序节点中序号最小的一个. 当释放锁的时候, 只需将这个瞬时节点删除即可. 同时, 其可以避免服务宕机导致的锁无法释放, 而产生的死锁问题.

细节问题:

* 客户端宕机导致锁无法释放: 一旦客户端获取到锁之后突然挂掉, 临时节点就会自动删掉.
* 阻塞锁: 客户端创建顺序节点, 并在节点上绑定监听器, 一旦节点有变化, Zookeeper会通知客户端, 客户端可以检查自己创建的节点是不是当前所有节点中序号最小的, 如果是, 那么自己就获取到锁, 便可以执行业务逻辑了.
* 可重入: 客户端在创建节点的时候, 把客户端的主机信息,线程信息直接写入节点中, 下次想要获取锁的时候和当前最小的节点中的数据对比一下就可以了.
* 单点问题: 只要有半数以上的机器存活, 就可以对外提供服务;

## Watch机制

watch在zookeeper中非常重要, 它能够让应用程序监听zookeeper上节点的变化, 从而及时做出响应.

* 服务端
  * WatchManager: 管理所有watcher操作, 包括: 注册, 注销, 触发
* 客户端
  * ZkWatcherManager: 管理所有客户端watcher相关操作, 包括: 创建, 注册, 事件处理等;

工作机制如下:

1. 客户端连接到ZK, 会创建一个ZkWatcherManager, 用于管理客户端中的所有watcher;
2. 当客户端想要监控某个znode节点时, 它可以调用ZkWatcherManager中的方法创建watcher, 并注册到客户端. 客户端将watcher信息发送到ZK服务端;
3. 服务端收到消息后, 交给WatchManager进行注册, 将信息保存在内存中;
4. 节点发生变化时, WatchManager会通知ZK Server
5. ZK Server会根据变化类型通知对应客户端, 告知它们发生了哪些变化;
6. 客户端接收到通知后, ZkWatcherManager会根据watcher的类型来触发对应的事件处理方法;

## 服务发现

可以这样实现服务发现:

1. 向ZK注册服务: 服务提供者在ZK上创建**临时节点**, 来注册自己. 节点名称通常是服务名称和版本号等信息的组合, 节点数据可以包含服务地址, 端口, 协议等信息. 因为是临时节点, 所以当服务提供者关闭或者崩溃时, 节点自动删除.
2. 客户端订阅服务: 服务消费者需要订阅自己所需的服务, 可以监听服务节点变化, 一旦节点变化, 就会收到通知.

## 缺点

1. 性能问题: ZK设计是为了高一致性, ZAB协议需要同步写操作到大多数节点, 导致写操作的性能较低. 在高并发写入场景下, Zookeeper的新能称为瓶颈.
2. ZK写操作必须经过Leader节点, Leader将成为集群的瓶颈;
3. ZK使用内存存储数据, 如果数据量过大, 会导致内存不足或者性能下降;
4. 如果频繁触发Leader选举, 会影响可用性;
5. 易用性和工具生态略显不足, 运维和管理复杂度较高;