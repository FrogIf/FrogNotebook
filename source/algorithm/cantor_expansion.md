---
title: 康托展开
author: frogif
date: 2022-05-02
---

# 康托展开

## 概述

康托展开与逆展开是将全排列和它的字典序互相转化的两种算法.

给定一个序列[a, b, c, d], 它的所有全排列与自然数之间可以建立一个映射关系:

```
[a, b, c, d] -- 0
[a, b, d, c] -- 1
[a, c, b, d] -- 2
[a, c, d, b] -- 3
[a, d, b, c] -- 4
[a, d, c, b] -- 5
[b, a, c, d] -- 6
[b, a, d, c] -- 7
[b, c, a, d] -- 8
[b, c, d, a] -- 9
[b, d, a, c] -- 10
[b, d, c, a] -- 11
[c, a, b, d] -- 12
[c, a, d, b] -- 13
[c, b, a, d] -- 14
[c, b, d, a] -- 15
[c, d, a, b] -- 16
[c, d, b, a] -- 17
[d, a, b, c] -- 18
[d, a, c, b] -- 19
[d, b, a, c] -- 20
[d, b, c, a] -- 21
[d, c, a, b] -- 22
[d, c, b, a] -- 23
```

这里面的排序规则, 一般称为字典序.

康托展开就可以实现将左侧的序列映射到右侧的自然数. 只需要用到一个公式:

$$
X = a_1(n - 1)! + a_2(n - 2)! + ...+ a_i(n - i)! + ... + a_n \cdot 0!
$$

其中, $a_i$表示, 第i位元素后面, 所有比当前位小的元素个数. 例如, 对于[d, b, a, c]:

```
3 * (4 - 1)! + 1 * (4 - 2)! + 0 * (4 - 3)! + 0 * (4 - 4)! = 20
```

## 原理解释

观察上面的所有全排列, 首先, 我们只看开头第一个字符, 可以看到, 以a开头的序列有6个, 以b开头的也有6个, 以此类推, 每一个开头的都有6个. 这是因为, 第一位固定的情况下, 其余三位的排列个数就是3!=6. 这样, 可以总结出一个关于**某个字符占据索引范围**的规律:

假设S是一个n个字符的序列, 以其中的字符S[k]开头的排列, 编号范围是: $[k * (n - 1)!, (k + 1) * (n - 1)!)$

接下来, 我们单独看以a开头的排列:

```
[a, b, c, d] -- 0
[a, b, d, c] -- 1
[a, c, b, d] -- 2
[a, c, d, b] -- 3
[a, d, b, c] -- 4
[a, d, c, b] -- 5
```

这时, a就是冗余的信息了, 可以忽略, 实际上, 就是对序列[b, c, d]进行排列, 单看[b, c, d]这个序列, 还是应用上面的结论, 可以知道以每个字符开头的编号范围$[k' * (n - 1 - 1)!, (k' + 1) * (n - 1 - 1)!)$

注意, 首先, 明确一下文中的k和k'的含义, k和k'都是待排列序列在自然顺序下的索引, 然后, 对于[b, c, d]这个序列, 有$k'_b = 0, k'_c = 1, k'_d = 2$, 也可以表示成: $k'_b = k_b - 1, k'_c = k_c - 1, k'_d = k_d - 1$

回到上面四个字符的排列, 如果观察以b开头的部分:

```
[b, a, c, d] -- 6
[b, a, d, c] -- 7
[b, c, a, d] -- 8
[b, c, d, a] -- 9
[b, d, a, c] -- 10
[b, d, c, a] -- 11
```

就是对序列[a, c, d]进行排列, 还是应用上面的结论, 可以知道每个字符开头的编号范围是$[k' * (n - 1 - 1)!, (k' + 1) * (n - 1 - 1))$

这里的k'值是这样的:

$$
k'_a = k_a\\
k'_c = k_c - 1\\
k'_d = k_d - 1
$$

进一步归纳, 假设子序列中有一个元素x, 它在子序列中的索引位置与在完整序列中是不同的, 有些元素在完整序列中, 会出现x前面, 而在子序列中, 不存在这个元素, 那么, x就需要向前"缩进", 补齐空缺的位置, 如果原来在x前面的元素中, 有5个不在子序列中, 那么x的索引位置就会向前前进5.

所以我们可以得到这样一个关于**完整排列和子排列中元素序号关系**规律, 子序列中, 每个元素的索引值k'与完整序列中的索引值k存在这样的关系:

```
k' = k - m (其中, m是在完整序列中存在于x前, 但是在子序列中不存在的元素个数)
```

接下来, 我们把上面两个结论结合到一起, 对于一个n个元素的序列S.

首位如果以$S(k_1)$开头, 那么它的编号范围是$[k_1 * (n - 1)!, (k_1 + 1) * (n - 1)!)$

第二位如果以$S(k')$开头, 那么它在子序列中的编号范围是$[k' * (n - 2), (k' + 1) * (n - 2)!)$

显然, 它在完整序列中的编号范围是: $[k_1 * (n - 1)! + k' * (n - 2)!, k_1 * (n - 1)! + (k' + 1) * (n - 2)!)$

又, $k' = k_2 - m$, 所以有$[k_1 * (n - 1)! + (k_2 - m) * (n - 2)!, k_1 * (n - 1)! + (k_2 - m + 1) * (n - 2)!)$

以此类推, 可以得到第i位的编号范围为: 

$$
[\\
    k_1 * (n - 1)! + (k_2 - m_2) * (n - 2)! + ... + (k_i - m_i) * (n - i)!, \\
    k_1 * (n - 1)! + (k_2 - m_2) * (n - 2)! + ... + (k_i - m_i + 1) * (n - i)! \\
)
$$

当i = n时:

$$
[\\
    k_1 * (n - 1)! + (k_2 - m_2) * (n - 2)! + ... + (k_{n-1} - m_{n-1}) * (n - n)!,\\ 
    k_1 * (n - 1)! + (k_2 - m_2) * (n - 2)! + ... + (k_{n-1} - m_{n-1} + 1) * (n - n)!\\
)
$$

> 注: 0! = 1

此时, 编号范围中, 只有一个编号--$k_1 * (n - 1)! + (k_2 - m_2) * (n - 2)! + ... + (k_{n-1} - m_{n - 1})$, 这就意味着, 第n位的编号只能是$k_1 * (n - 1)! + (k_2 - m_2) * (n - 2)! + ... + (k_{n-1} - m_{n-1})$, 此时, 从首位(第1位)到第n位的都已经确定了, 所以这个编号, 就是从第1位到第n位全部确定下来的一个排列的编号.

总结一下, 任意一个由n个元素构成的排列, 其字典序下的编号是:

$$
k_1 * (n - 1)! + (k_2 - m_2) * (n - 2)! + ... + (k_i - m_i) * (n - i)! + ... + (k_{n-1} - m_{n-1}) * (n - n)!
$$

其中, 
$k_i$ -- 第i个元素在完整序列中的索引位置
$m_i$ -- 第i个元素的所有前面的元素, 实际出现在它前面的个数

举个例子: 求{4, 2, 1, 3}的康托展开值:

```
第1位是4, 它在完整序列中的索引位置是k_1 = 4 - 1 = 3, 它前面的元素有: {1, 2, 3}, 实际出现的0个, 所以m_1 = 0
第2位是2, 它在完整序列中的索引位置是k_2 = 2 - 1 = 1, 它前面的元素有: {1}, 实际出现的0个, 所以m_2 = 0
第3位是1, 它在完整序列中的索引位置是k_3 = 1 - 1 = 0, 它前面没有元素, 所以m_3 = 0
第4位是3, 它在完整序列中的索引位置是k_4 = 3 - 1 = 2, 它前面的元素有: {1, 2}, 实际出现的有: {1, 2}, 所以m_4 = 2
3 * (4 - 1)! + (1 - 0) * (4 - 2)! + (0 - 0) * (4 - 3)! + (2 - 2) * (4 - 4)! = 20
```


## 康托展开

上面实际上就是康托展开了, 下面给出康托展开的完整定义:

设$a_{1...n}$表示一个n阶全排列, 设$a_i$表示这个全排列的第$i$位数字. 定义$a_{1...n}$的退位序列$b_{1...n}$, $b_j$等于$a_j$在全排列中作顺序对后项的顺序对个数, 形式化的表达为:$\forall 1 \leq j \leq n, b_j = |\{(a_i, a_j)| 1 \leq i \leq j, a_i < a_j \}|$

康托展开是一个函数, 它把一个n阶全排列映射到它在所有n全排列中按字典序排列的排名(从0开始).

$$F:\{a_{1...n}\} \rightarrow [0 ... (n! - 1)]$$

$$F(a_{1...n}) = \sum_{i=1}^n (a_i - b_i - 1) * (n - i)!$$

关于康托展开的其他表述方式:

$$
X = a_1(n - 1)! + a_2(n - 2)! + ...+ a_i(n - i)! + ... + a_n \cdot 0!
$$

其中, $a_i$表示, 第i位元素前面的所有元素中, 没有出现在它前面的元素个数.

我们依旧使用{4, 2, 1, 3}作为例子, 使用这种方式进行计算:

```
第1位是4 --> 它前面有3个元素:{1, 2, 3}, 都没有出现在它前面, 所以a_1 = 3
第2位是2 --> 它前面有1个元素:{1}, 都没有出现在它前面, 所以a_2 = 1
第3位是1 --> 它前面有0个元素, 所以a_3 = 0
第4位是3 --> 它前面有2个元素:{1, 2}, 都出现在了它前面, 所以a_4 = 0
所以:
3 * (4 - 1)! + 1 * (4 - 2)! + 0 * (4 - 3)! + 0 * (4 - 4)! = 20
```

对于这个例子, 还可以这么计算:

```
第1位是4 --> 它后面比它小的数字有: {2, 1, 3}, 所以a_1 = 3
第2位是2 --> 它后面比它小的数字有: {1}, 所以a_2 = 1
第3位是1 --> 它后面比它小的数字有: {}, 所以a_3 = 0
第4位是3 --> 它后面比它小的数字有: {}, 所以a_4 = 0
```

> 显然最后一位是不需要计算的, 因为最后一位前面的元素肯定都出现在它前面, 同样, 最后一位后面比它小的数字永远是0, 所以最后一项的结果永远是0

代码实现:

```java
/*
    * 求一个自然数序列在康托展开下的结果
    * 注: 没有做数据溢出相关处理
    */
public static int cantorExpansion(int[] nums){
    int result = 0;
    for(int i = 0; i < nums.length - 1; i++){
        int a = nums[i];
        int m = 0;
        for(int j = i + 1; j < nums.length; j++){
            if(a > nums[j]){
                m++;
            }
        }
        result = (result + m) * (nums.length - i - 1);
    }
    return result;
}
```

这段代码的时间复杂度是$\theta(n^2)$, 可以采用树状数组进行优化(TODO).


## 逆康托展开

康托展开是一个全排列到一个自然数的双射, 所以, 可以由一个自然数, 得到一个全排列.

首先, 我们知道了康托展开的公式:

$$
X = a_1(n - 1)! + a_2(n - 2)! + ...+ a_i(n - i)! + ... + a_n \cdot 0!
$$

如果我们将这个式子除以$(n - 1)!$会得到:

$$
a_1 + \frac{a_2(n - 2)! + ...+ a_i(n - i)! + ... + a_n \cdot 0!}{(n-1)!}
$$

而这里$\frac{a_2(n - 2)! + ...+ a_i(n - i)! + ... + a_n \cdot 0!}{(n-1)!}$是小于1的, 附录中给出了证明过程.

有了这个结论, 我们就很容易进行逆康托展开了, $X / (n - 1)!$向下取整后, 得到$a_1$, 取余后, 得到$a_2(n - 2)! + ...+ a_i(n - i)! + ... + a_n \cdot 0!$.

再用取余的结果, 除以$(n - 2)!$, 向下取整, 得到$a_2$, 取余得到$a_3(n - 3)! + ...+ a_i(n - i)! + ... + a_n \cdot 0!$.

反复执行下去, 我们会得到: $a_1, a_2, a_3, a_4, ..., a_n$.

接下来, 首先$a_1$表示第1位后面比自身小的元素个数, 因为它后面包含了除它自身以外的所有数字, 所以它自身在自然顺序中的索引为$a_1$.

然后, 对于第2位, $a_2$表示第2位后面比自身小的所有元素个数, 这时, 将完整序列中剔除第1位上的数字, 那么它在这个子序列中的索引为$a_2$.

同样的, 对于第3位, $a_3$表示第3位后面比自身小的所有元素个数, 这时, 将完整序列中剔除第1位和第2位上的数字, 则它在子序列中的索引为$a_3$.

通过上面的描述, 就可以知道逆康托展开应该如何操作了.

依旧以上面的例子做演示, 我们知道{4, 2, 1, 3}对应的康托展开值是20, 那么, 我们接下来反向, 通过20还原回去.

```
第1位:
20 / 3! = 3
20 % 3! = 2
所以, 第1位后面小于第1位的元素有3个, 所以第一位为4

第2位:
2 / 2! = 1
2 % 2! = 0
所以, 第2位后面小于第2位的元素有1个, 在剔除第1位的子序列{1, 2, 3}中, 可以确定它是2

第3位:
0 / 1! = 0
0 % 1! = 0
所以, 第3位后面小于第3位的元素有0个, 在剔除1,2位的子序列{1, 3}中, 可以确定它是1

第4位:
0 / 0! = 0
0 % 0! = 0
所以, 第4位后面小于第4位的元素有0个, 在剔除1,2,3位的子序列{3}中, 可以确定它是3
```

代码实现如下:

```java
public static int[] invCantorExpansion(int num, int n){
        int[] a = new int[n];
        for(int i = 0; i < n; i++){
            a[n - i - 1] = num % (i + 1);
            num /= (i + 1);
        }
        int[] used = new int[n];
        int[] result = new int[n];
        for(int i = 0; i < n; i++){
            int j = 0;
            int p = 0;
            int l = a[i] + 1;
            while(true){
                if(used[j] == 0){
                    p++;
                }
                if(p == l){
                    break;
                }
                j++;
            }
            used[j] = 1;
            result[i] = j + 1;
        }
        return result;
    }
```

这段代码的时间复杂度是$\theta(n^2)$, 也可以采用树状数组进行优化(TODO)

## 附录

证明: 在康托展开中, $\frac{a_2(n - 2)! + ...+ a_i(n - i)! + ... + a_n \cdot 0!}{(n-1)!} < 1$.

首先, 我们知道$a_2$表示第2位后面有多少个小于它的数, 假设它后面所有的数都比它小, 那么$a_2 = n - 2$, 因此, 我们知道$a_i \leq n - i$.

所以有:

$$
\frac{a_2(n - 2)! + ...+ a_i(n - i)! + ... + a_n \cdot 0!}{(n-1)!} \leq \frac{(n - 2)(n - 2)! + (n - 3)(n - 3)! + ...+ (n - i)(n - i)! + ... + a_n \cdot 0!}{(n-1)!}
$$

那么, 要证明的结论就可以转化为, 证明:

$$
(n - 2)(n - 2)! + (n - 3)(n - 3)! + ...+ (n - i)(n - i)! + ... + (n - n)(n - n)! < (n - 1)!
$$

我们对$(n - 1)!$进行展开:

$$
(n - 1)! \\
= (n - 2 + 1)(n - 2)! \\
= (n - 2)(n - 2)! + (n - 2)! \\
= (n - 2)(n - 2)! + (n - 3 + 1)(n - 3)! \\
= (n - 2)(n - 2)! + (n - 3)(n - 3)! + (n - 3)! \\
... \\
= (n - 2)(n - 2)! + (n - 3)(n - 3)! + ... + (n - i)(n - i)! + (n - i)! \\
= (n - 2)(n - 2)! + (n - 3)(n - 3)! + ... + (n - i)(n - i)! + ... + (n - n)(n - n)! + (n - n)! \\
$$

通过展开之后, 证明结论, 也就是证明$0 < 1$, 这显然成立, 因此证明完毕.


## Reference

* https://zhuanlan.zhihu.com/p/39377593
* https://github.com/hkociemba/CubeExplorer/blob/master/CubiCube.pas