# 常用缓存淘汰算法

缓存在一定时间之后, 如果遇到存储空间不足的情况下, 需要被淘汰, 防止对整个系统造成影响. 这时就需要有缓存淘汰算法.

* LRU(最近最少使用) - 每次访问数据, 都会将其放在队尾, 如果需要淘汰数据, 就只需淘汰队首即可.
  * 存在的问题: 如果一个数据在1分钟内访问了1000次, 在后1分钟没有访问, 会导致这个热点数据被淘汰
* LFU(最近最少频率使用) - 利用额外空间记录每个数据的使用频率, 然后选出频率最低的进行淘汰.
  * 存在的问题: 无法对一个拥有最初最高访问率, 之后长时间没有访问的数据负责.
* FIFO(先进先出) - 就是用一个队列实现, 淘汰时直接淘汰队首.
  * 存在的问题: 先进入缓存的会先被淘汰, 导致缓存命中率很低

上面的算法各有利弊, 实际应用用, 根据不同的场景进行选择.

**应用举例**

mysql的Innodb引擎, 提供了Buffer Pool. 存储引擎会在查询或者更新时, 将数据页加载至内存中, 这就是Buffer Pool. Buffer Pool会加速查询效率. 但是也需要适时的淘汰一些缓存页, 这时, 就用到了LRU, 并且做出了一些调整. 具体的说, innodb的LRU采用链表来实现. 

首先, 假设使用标准的LRU, 看一下会出现什么问题. 这时, 当全表查询时, 会把一张表的所有数据页全都加载到buffer pool, 如果数据量较大, 可能会导致原来buffer pool中的热点数据全部被淘汰. 而全表查询加载进来的这些数据, 可能就访问这一次就再也不访问了.

所以, innodb对LRU进行了改进, 按照5:3的比例, 将整个LRU链表分为young区和old区. young区在链表前部, 占5/8, old区在链表后部, 占3/8. 新加入的数据, 首先被放入old区域的头部. 之后每次访问时, 如果这个数据页在链表中存在的时间超过了1秒, 就移动到链表头部, 也就是young区的头部. 如果访问间隔不超过1秒, 就依旧保留在old区. 这样就解决了全表扫描导致热点数据被淘汰的问题, 全表扫描的数据会被加载到old区, 然后, 再次访问该数据页的时间一定会小于1秒, 所以保持在old区不动. 这样, young区中的热点数据就不受影响.


> 还有很多应用, 例如redis, guava cache, coffine cache等.