# 布隆过滤器

布隆过滤器经常用来判断一个元素是否在一个集合中. 例如, 判断一个单词是否有拼写错误(单词是否在字典中), 判断一个地址是否在黑名单中等.

常规的用于判断元素是否在集合中的做法是使用Hash, 时间复杂度为O(1), 但是一旦数据量过大, 将会消耗大量的内存. 所以, 当数据量较大时, 一般采用布隆过滤器来解决.

**前置概念 -- 位图**

布隆过滤器本身是基于位图实现的. 这里先描述一下位图.

假设有1千万个整数, 整数的范围在1--1亿之间, 如何快速查找某个整数是否在这一千万个整数中? 可以这样处理:

申请一个大小为1亿的布尔类型数组. 将一千万个整数作为数组的下标, 对应的数组值设置为true. 当查询某个整数是否存在时, 只需将对应的数组值取出来, 看是否等于true即可. 如果想更进一步减少内存, 可以使用一个二进制位来标记每一个整数是否存在. 这样, 1亿个位置, 实际上只需要100000000/8/1024/1024=12MB即可.

位图就是使用一个二进制位的1来代表一个元素存在. 但是这里也是假设数据范围不是很大, 如果很大, 例如10亿, 就需要120MB了.

**布隆过滤器**

为了进一步减小位图占用的内存空间, 需要使用布隆过滤器. 现在假设数据的范围是1--200之间的100个数字. 如果我们使用100位来代表这200个数字, 需要怎么实现呢? 可以取100位中的两位来表示一个数字是否存在, 如果这2位都是1, 则存在, 否则不存在. 这种情况下, 100位实际上可以表示C(100,2)=100*99/2=4950个数字. 当然, 还可以用3位, 4位...

具体的来说, 以2位表示为例, 定义两个hash函数, 生成两个不同的索引值. 存入数据时, 就把指定的两位置为1. 

这样存在一个问题, 两个不同的数字num1和num2经过hash函数之后, 结果一样, 也就存在了hash冲突, 导致误判. 实际上只要让误判结果概率足够低, 结果就可信. 举例来说, 假设hash函数个数为k, 二进制位数为m, 元素个数n. 当m/n = 16, k = 8, 误判率为万分之五.

布隆过滤器的误判是这样的:

* 如果一个元素在集合中, 那么布隆过滤器绝对不会漏掉;
* 如果一个元素不在集合中, 则有可能判定在集合中.

> 误判举例: 垃圾邮件黑名单, 布隆过滤器绝对不会漏掉黑名单中的任何一个地址, 但是有极小概率将一个不在黑名单上的电子邮件判定为在黑名单中.

布隆过滤器的数学原理在于完全随机的两个数字相冲突的概率很小, 因此可以在很小的误判率条件下, 用很少的空间存储大量的信息. 解决误判的常见方法, 就是建立一个小的白名单, 存储那些可能被误判的信息.

**布隆过滤器删除**

如何对布隆过滤器进行删除? 由于存在hash冲突, 直接删除是不行的, 会导致误删.

* 方案1: 起一个定时任务, 每隔几个小时, 自动创建一个新的布隆过滤器数组, 替换老的.
* 方案2: 增加一个等长的数组, 存储计数器, 主要解决冲突问题, 每次删除时, 对应的计数器减1, 如果结果为0, 更新主数组的二进制值为0.