# 异或

## 概述

在逻辑学中，逻辑算符异或（exclusive or）是对两个运算元的一种逻辑析取类型，符号为 XOR 或 EOR 或 ⊕（编程语言中常用^）。
与一般的逻辑或不同，异或算符的值为真仅当两个运算元中恰有一个的值为真，而另外一个的值为非真。转化为命题，就是：“两者的值不同。”或“有且仅有一个为真。”

> 以下使用java中的位运算符进行表示. 与(&), 或(|), 非(~), 异或(^).


Y|B=0|B=1
---|---|---
A=0|0|1
A=1|1|0

表达式:
```
Y = A ^ B = ~A & B | A & ~B
```

## 异或的特性

1. 恒等律:
    ```
     X ^ 0 = X
    ```
2. 归零律
    ```
     X ^ X = 0
    ```
3. 交换律
    ```
    A ^ B = B ^ A
    ```
4. 结合律
    ```
    A ^ (B ^ C) = (A ^ B) ^ C
    ```
    证明:
    ```
    A ^ (B ^ C) = A ^ (~B & C | B & ~C)
         = ~A & (~B & C | B & ~C) | (A & ~(~B & C | B & ~C))
         = (~A & ~B & C) | (~A & B & ~C) | (A & (~(~B & C) & ~(B & ~C)))
         = (~A & ~B & C) | (~A & B & ~C) | (A & ((B | ~C) & (~B | C)))
         = (~A & ~B & C) | (~A & B & ~C) | (A & (((B | ~C) & ~B) | ((B | ~C) & C))
         = (~A & ~B & C) | (~A & B & ~C) | (A & ((~C & ~B) | (B & C))
         = (~A & ~B & C) | (~A & B & ~C) | (A & ~C & ~B) | (A & B & C)
         
    A ^ B ^ C = ((~A & B) | (A & ~B)) ^ C
         = ~((~A & B) | (A & ~B)) & C | (((~A & B) | (A & ~B)) & ~C)
         = (~(~A & B) & ~(A & ~B)) & C | ((~A & B & ~C) | (A & ~B & ~C))
         = ((A | ~B) & (~A | B)) & C | (~A & B & ~C) | (A & ~B & ~C)
         = ((A & B) | (~B & ~A)) & C | (~A & B & ~C) | (A & ~B & ~C)
         = (A & B & C) | (~A & ~B & C) | (~A & B & ~C) | (A & ~B & ~C)
    
    所以: A ^ B ^ C = A ^ (B ^ C)
    ```
    
> 使用到的:   
>   交换律: A & B = B & A, A | B = B | A   
>   结合律: A & B & C = A & (B & C), A | B | C = A | (B | C)    
>   分配律: A & (B | C) = (A & B) | (A & C), A | (B & C) = (A | B) & (A | C)   
>   摩尔定律: ~(A & B) = ~A | ~B, ~(A | B) = ~A & ~B

5. 自反
    ```
    A ^ B ^ B = A
    ```


## 异或的应用

**快速比较两个值**

```java
boolean eq = (a ^ b) == 0;    // 比较两个int类型值a, b是否相等
```

**使用异或翻转指定位**

```java
int k = 0b11111;
k = k ^ (1 << 3);
System.out.println(k);	// DEC: 23, BIN: 10111
```

使用的异或特性:
```
1 ^ 1 = 0
0 ^ 1 = 1
```

**判断一个二进制数中1的数量是奇数个还是偶数个**

例如：求10100001中1的数量是奇数还是偶数?
答案：1 ^ 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 = 1

> 结果为1就是奇数个1，结果为0就是偶数个1.

> 这条性质可用于奇偶校验（Parity Check），比如在串口通信过程中，每个字节的数据都计算一个校验位，数据和校验位一起发送出去，这样接收方可以根据校验位粗略地判断接收到的数据是否有误.

**校验和恢复**

校验和恢复主要利用的了异或的特性：IF a ^ b = c THEN a ^ c = b.

应用：一个很好的应用实例是RAID5，使用3块磁盘（A、B、C）组成RAID5阵列，当用户写数据时，将数据分成两部分，分别写到磁盘A和磁盘B，A ^ B的结果写到磁盘C；当读取A的数据时，通过B ^ C可以对A的数据做校验，当A盘出错时，通过B ^ C也可以恢复A盘的数据。(RAID5的实现比上述的描述复杂多了，但是原理就是使用 异或)


**不使用其他空间，交换两个值**

```
a = a ^ b;
b = a ^ b; //a ^ b ^ b = a ^ 0 = a;
a = a ^ b;
```

> 非常经典的题目

**一个整型数组里除了N个数字之外，其他的数字都出现了两次，找出这N个数字**

1. 一个整型数组中只有一个数字出现了一次, 其余数字都出现了两次

假设这个数组为:{A, B, C, B, C, D, A}

使用异或:

```
A ^ B ^ C ^ B ^ C ^ D ^ A
= A ^ A ^ B ^ B ^ C ^ C ^ D
= 0 ^ D
= D
```

这样就把只出现一次的数组找出来了.

2. 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字?

 第一步：肯定还是像我们上面的解法一样，所有数进行异或，不过最终得到的结果是 a 和 b（假设 a 和 b 是落单的数字）两个值的异或结果 a ^ b，没有直接得到 a 和 b 的值;
 
 第二步: 假设上一步的结果是00001001, 那么这个数值为1的位上, 表示a, b两个数在这个位上不同(例如从右向左的第一位), 根据这个特点, 可以找到, 这个位上为1(例如第一位)的数进行异或, 就可以得到a或者b;
 
 第三步: 经过上步已经得到了a或者b(假设是a), 根据异或自反性可有: b = a ^ b ^ a;
 
 代码如下:
 
```java
    int aXORb = 0;
    int[] arr = {1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 8, 9, 8};
    
    for(int i = 0; i < arr.length; i++) {
    	aXORb ^= arr[i];
    }
    
    // 输出 num 的低位中的第一个 1 的位置, 即 num & -num
    int firstOneBit = aXORb & ~(aXORb - 1);  // 1110 & ~(1110 - 1) = 1110 & ~(1101) = 1110 & 0010 = 0010
    
    int a = 0;
    int b = 0;
    for(int i = 0; i < arr.length; i++) {
    	if((firstOneBit & arr[i]) != 0) {
    		a ^= arr[i];
    	}
    }
    b = aXORb ^ a;
    
    System.out.println(a);
    System.out.println(b);
```