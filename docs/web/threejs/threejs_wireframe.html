<!DOCTYPE html>
<html>
<head>
<title>threejs_wireframe.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="threejs%E7%BA%BF%E6%A1%86">threejs线框</h1>
<h2 id="%E6%A6%82%E8%BF%B0">概述</h2>
<p>网上对threejs线框已经有大量的教程了, 但是如果开发的是一个CAD程序, 这些线框就不太合适了. 如图是catia中, 一个模型的线框效果:</p>
<p><img src="img/catia_wireframe.png" alt="image"></p>
<p>对网上给出的线框方案做一个汇总, 然后给出实现catia中线框效果的一种方案.</p>
<ul>
<li>通过材质中的属性来显示线框;</li>
<li>通过EdgesGeometry生成线框;</li>
<li>通过BufferGeometry中的position和index检测出线框(就是实现catia中线框的效果).</li>
</ul>
<h2 id="%E6%9D%90%E8%B4%A8%E7%BA%BF%E6%A1%86">材质线框</h2>
<p>关键代码如下:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 材质线框</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">materialWireframe</span>(<span class="hljs-params">model, isShow</span>)</span>{
    <span class="hljs-keyword">if</span>(model){
        model.traverse(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> {
            <span class="hljs-keyword">if</span>(child.isMesh){
                child.material.wireframe = isShow;
            }
        });
    }
}
</div></code></pre>
<p>效果如下:</p>
<p><img src="img/material_wireframe.png" alt="image"></p>
<h2 id="edgesgeometry">EdgesGeometry</h2>
<p>关键代码如下:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// EdgesGeometry线框</span>
<span class="hljs-keyword">var</span> line = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">const</span> lineMaterial = <span class="hljs-keyword">new</span> THREE.LineBasicMaterial({<span class="hljs-attr">color</span>: <span class="hljs-number">0x4080ff</span>});
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">edgeGeometryWireframe</span>(<span class="hljs-params">model, isShow</span>)</span>{
    <span class="hljs-keyword">if</span>(model){
        <span class="hljs-keyword">if</span>(!line){
            line = <span class="hljs-keyword">new</span> THREE.Group();
            model.traverse(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">child</span>)</span>{
                <span class="hljs-keyword">if</span> (child.isMesh){
                    <span class="hljs-keyword">let</span> edges = <span class="hljs-keyword">new</span> THREE.EdgesGeometry(child.geometry);
                    <span class="hljs-keyword">let</span> lineS= <span class="hljs-keyword">new</span> THREE.LineSegments(edges, lineMaterial);
                    line.add(lineS);
                }
            });
            scene.add(line);
        }
        model.visible = !isShow;
        line.visible = isShow;
    }
}
</div></code></pre>
<p>效果如下:</p>
<p><img src="img/edgesgeometry.png" alt="image"></p>
<blockquote>
<p>此外, 像这样<code>new THREE.EdgesGeometry(child.geometry, 10)</code>, 可以通过增加一个参数, 这个参数的意思是相邻面的法线夹角, 这段代码就是指, 只有相邻面法线夹角大于10度(单位: 角度)时, 才会渲染边缘</p>
</blockquote>
<h2 id="%E9%80%9A%E8%BF%87buffergeometry%E4%B8%AD%E7%9A%84position%E5%92%8Cindex%E7%94%BB%E7%BA%BF%E6%A1%86">通过BufferGeometry中的position和index画线框</h2>
<p>这里说明一下, 每一个Mesh都是有两部分组成, 一部分是geometry, 一部分是material, 而geometry都是由一些点组成的, 每三个点为一组, 确定一个三角面, 一系列的三角面组成最终的模型. 这种画线方式思路是, 遍历这些三角面的边, 判断哪些边是多个三角面共用的, 如果是共用的, 那么就不是边缘; 如果不是共用的, 也就是只有一个三角面用到了这个边, 那么这个边就是一个mesh的边缘.</p>
<p>这里主要需要用到两个属性:</p>
<ul>
<li>xxxMesh.geometry.attributes.position -- 编织这个mesh的所有的点;</li>
<li>xxxMesh.geometry.index -- 这些点是如何编织的</li>
</ul>
<p>根据这两个属性, 就可以画出一个图形了, 具体过程如下:</p>
<p>假设, 有这样4个点: [(0, 0, 1), (0, 1, 0), (1, 0, 0), (1, 1, 0)],</p>
<p>那么在geometry中, geometry.attributes.position = [0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0]</p>
<blockquote>
<p>注意, 这里去掉了一些不必要的细节, geometry.attributes.position并不是一个数组.</p>
</blockquote>
<p>然后, 如果0, 1, 2点确定了一个三角面, 1, 2, 3点确定了一个三角面.</p>
<p>那么, 在geometry.index = [0, 1, 2, 1, 2, 3], 即三个为一组, 共两个三角面.</p>
<p>根据上面的介绍, 就对Mesh的绘制有了一定的了解了. 接下来直接给出代码:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// catia样式的线框</span>
<span class="hljs-keyword">var</span> catiaLine = <span class="hljs-literal">null</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">catiaWireframe</span>(<span class="hljs-params">model, isShow</span>)</span>{
    <span class="hljs-keyword">if</span>(model){
        <span class="hljs-keyword">if</span>(!catiaLine){
            catiaLine = <span class="hljs-keyword">new</span> THREE.Group();
            model.traverse(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> {
                <span class="hljs-keyword">if</span>(child.isMesh){
                    <span class="hljs-keyword">let</span> pointIndex = fetchEdgePoint(child);
                    <span class="hljs-keyword">if</span>(pointIndex){
                        <span class="hljs-keyword">let</span> posArr = child.geometry.attributes.position;
                        <span class="hljs-keyword">let</span> points = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();
                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; pointIndex.length; i += <span class="hljs-number">2</span>){
                            <span class="hljs-keyword">let</span> k = pointIndex[i];
                            <span class="hljs-keyword">let</span> p = pointIndex[i + <span class="hljs-number">1</span>];
                            points.push(<span class="hljs-keyword">new</span> THREE.Vector3(posArr.getX(k), posArr.getY(k), posArr.getZ(k)));
                            points.push(<span class="hljs-keyword">new</span> THREE.Vector3(posArr.getX(p), posArr.getY(p), posArr.getZ(p)));
                        }
    
                        <span class="hljs-keyword">if</span>(points.length &gt; <span class="hljs-number">0</span>){
                            <span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> THREE.BufferGeometry().setFromPoints(points);
                            catiaLine.add(<span class="hljs-keyword">new</span> THREE.LineSegments(geometry, <span class="hljs-keyword">new</span> THREE.LineBasicMaterial({<span class="hljs-attr">color</span>: <span class="hljs-number">0x4080ff</span>})));
                        }
                    }
                }
            });
            scene.add(catiaLine);
        }
        model.visible = !isShow;
        catiaLine.visible = isShow;
    }
}
<span class="hljs-comment">// 边缘点探测</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchEdgePoint</span>(<span class="hljs-params">mesh</span>) </span>{
    <span class="hljs-keyword">let</span> pointIndexArr = mesh.geometry.index;
    <span class="hljs-keyword">if</span>(pointIndexArr){
        <span class="hljs-keyword">let</span> lineMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
        <span class="hljs-keyword">let</span> indexArr = pointIndexArr.array;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; indexArr.length; j += <span class="hljs-number">3</span>){
            <span class="hljs-keyword">let</span> a = indexArr[j];
            <span class="hljs-keyword">let</span> b = indexArr[j + <span class="hljs-number">1</span>];
            <span class="hljs-keyword">let</span> c = indexArr[j + <span class="hljs-number">2</span>];
            <span class="hljs-keyword">let</span> temp;
            <span class="hljs-keyword">if</span>(a &gt; b){ temp = b; b = a; a = temp; }
            <span class="hljs-keyword">if</span>(a &gt; c){ temp = a; a = c; c = temp; }
            <span class="hljs-keyword">if</span>(b &gt; c){ temp = b; b = c; c = temp; }

            <span class="hljs-keyword">let</span> info = lineMap.get(a);
            <span class="hljs-keyword">if</span>(!info){
                info = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
                lineMap.set(a, info);
            }

            <span class="hljs-keyword">let</span> co = info.get(b);
            info.set(b, co ? co + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);
            co = info.get(c);
            info.set(c, co ? co + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);
            
            info = lineMap.get(b);
            <span class="hljs-keyword">if</span>(!info){
                info = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
                lineMap.set(b, info);
            }
            co = info.get(c);
            info.set(c, co ? co + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);
        }

        <span class="hljs-keyword">let</span> pointIndex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> [k, v] <span class="hljs-keyword">of</span> lineMap.entries()){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> [p, count] <span class="hljs-keyword">of</span> v.entries()){
                <span class="hljs-keyword">if</span>(count == <span class="hljs-number">1</span>){
                    pointIndex.push(k);
                    pointIndex.push(p);
                }
            }
        }

        <span class="hljs-keyword">return</span> pointIndex;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
</div></code></pre>
<p>效果如下:</p>
<p><img src="img/geometry_points_line.png" alt="image"></p>
<h2 id="%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">完整代码</h2>
<p>除去three库以外, 完整代码如下:</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My first three.js app<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
			<span class="hljs-selector-tag">body</span> { <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>; }
		</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"background-image: linear-gradient(rgb(43, 43, 43), rgb(203, 202, 202));"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"importmap"</span>&gt;</span><span class="actionscript">
			{
				<span class="hljs-string">"imports"</span>: {
					<span class="hljs-string">"three"</span>: <span class="hljs-string">"./threejs/three.module.js"</span>
				}
			}
		</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span>&gt;</span><span class="javascript">
			<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> THREE <span class="hljs-keyword">from</span> <span class="hljs-string">'./threejs/three.module.js'</span>;
            <span class="hljs-keyword">import</span> { GLTFLoader } <span class="hljs-keyword">from</span> <span class="hljs-string">'./threejs/jsm/loaders/GLTFLoader.js'</span>;
            <span class="hljs-keyword">import</span> { RoomEnvironment } <span class="hljs-keyword">from</span> <span class="hljs-string">'./threejs/jsm/environments/RoomEnvironment.js'</span>;
            <span class="hljs-keyword">import</span> { OrbitControls } <span class="hljs-keyword">from</span> <span class="hljs-string">'./threejs/jsm/controls/OrbitControls.js'</span>;

            <span class="hljs-keyword">const</span> frustumSize = <span class="hljs-number">1000</span>;
            <span class="hljs-keyword">const</span> aspect = <span class="hljs-built_in">window</span>.innerWidth / <span class="hljs-built_in">window</span>.innerHeight;

            <span class="hljs-keyword">const</span> scene = <span class="hljs-keyword">new</span> THREE.Scene();
            <span class="hljs-comment">// const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);</span>
            <span class="hljs-keyword">const</span> camera = <span class="hljs-keyword">new</span> THREE.OrthographicCamera(frustumSize * aspect / - <span class="hljs-number">2</span>, frustumSize * aspect / <span class="hljs-number">2</span>, 
                frustumSize / <span class="hljs-number">2</span>, frustumSize / - <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2000</span>);
            camera.position.z = <span class="hljs-number">5</span>;

            <span class="hljs-keyword">const</span> renderer = <span class="hljs-keyword">new</span> THREE.WebGLRenderer({
                <span class="hljs-attr">alpha</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 背景透明</span>
                <span class="hljs-attr">antialias</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 抗锯齿</span>
            });
            renderer.setSize(<span class="hljs-built_in">window</span>.innerWidth, <span class="hljs-built_in">window</span>.innerHeight);
            <span class="hljs-built_in">document</span>.body.appendChild(renderer.domElement);

            <span class="hljs-keyword">const</span> controls = <span class="hljs-keyword">new</span> OrbitControls(camera, renderer.domElement);

            scene.environment = <span class="hljs-keyword">new</span> THREE.PMREMGenerator(renderer).fromScene(<span class="hljs-keyword">new</span> RoomEnvironment(), <span class="hljs-number">0.04</span>).texture;
            scene.add(<span class="hljs-keyword">new</span> THREE.DirectionalLight( <span class="hljs-number">0xFEFEFE</span> ));

            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">animate</span>(<span class="hljs-params"></span>) </span>{
                requestAnimationFrame( animate );
                renderer.render( scene, camera );
            }
            animate();

            <span class="hljs-keyword">const</span> loader = <span class="hljs-keyword">new</span> GLTFLoader();
            <span class="hljs-keyword">var</span> model = <span class="hljs-literal">null</span>;
            loader.load(<span class="hljs-string">"./vvv.glb"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">gltf</span>)</span>{
                model = gltf.scene;
                scene.add(gltf.scene);
                adaptModelSize(gltf.scene, camera);
            },<span class="hljs-literal">undefined</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> error </span>) </span>{
                <span class="hljs-built_in">console</span>.log(error);
            });

            <span class="hljs-comment">// 模型尺寸自适应</span>
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">adaptModelSize</span>(<span class="hljs-params">model, camera</span>)</span>{
                <span class="hljs-keyword">var</span> bBox = <span class="hljs-keyword">new</span> THREE.Box3().setFromObject(model);

                <span class="hljs-keyword">let</span> v = <span class="hljs-keyword">new</span> THREE.Vector3();
                bBox.getSize(v);

                <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> THREE.Vector3();
                bBox.getCenter(c);
                <span class="hljs-keyword">if</span>(camera.isOrthographicCamera){    <span class="hljs-comment">// 如果是正交相机</span>
                    <span class="hljs-keyword">let</span> start = <span class="hljs-keyword">new</span> THREE.Vector3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>).unproject(camera);
                    <span class="hljs-keyword">let</span> end = <span class="hljs-keyword">new</span> THREE.Vector3(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.5</span>).unproject(camera);
                    <span class="hljs-keyword">let</span> len = start.sub(end).length();
                    <span class="hljs-keyword">let</span> scale = len / <span class="hljs-built_in">Math</span>.sqrt(<span class="hljs-built_in">window</span>.innerHeight * <span class="hljs-built_in">window</span>.innerHeight + <span class="hljs-built_in">window</span>.innerWidth * <span class="hljs-built_in">window</span>.innerWidth);
                    <span class="hljs-keyword">let</span> height = <span class="hljs-built_in">window</span>.innerHeight * scale;
                    <span class="hljs-keyword">let</span> width = <span class="hljs-built_in">window</span>.innerWidth * scale;
            
                    <span class="hljs-keyword">let</span> maxSize = camera.near + c.length() + v.length();
                    camera.position.set(c.x, c.y, camera.far / <span class="hljs-number">2</span> + maxSize);
                    camera.lookAt(model.position);
                    camera.zoom = <span class="hljs-built_in">Math</span>.min(height / v.y, width / v.x);
                    camera.updateProjectionMatrix();
                }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(camera.isPerspectiveCamera){ <span class="hljs-comment">// 如果是透视相机</span>
                    <span class="hljs-keyword">var</span> dist = v.y / (<span class="hljs-built_in">Math</span>.tan(camera.fov * <span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">360</span>) * <span class="hljs-number">2</span>);
                    camera.position.set(model.position.x, model.position.y, v.z + dist * <span class="hljs-number">1.5</span>);
                    camera.lookAt(c);
                }
            }

            <span class="hljs-built_in">window</span>.onresize = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
                <span class="hljs-keyword">if</span>(camera.isOrthographicCamera){
                    <span class="hljs-keyword">let</span> aspect = <span class="hljs-built_in">window</span>.innerWidth / <span class="hljs-built_in">window</span>.innerHeight;
                    
                    camera.left = - frustumSize * aspect / <span class="hljs-number">2</span>;
                    camera.right = frustumSize * aspect / <span class="hljs-number">2</span>;
                    camera.top = frustumSize / <span class="hljs-number">2</span>;
                    camera.bottom = - frustumSize / <span class="hljs-number">2</span>;

                    camera.updateProjectionMatrix();
                    renderer.setSize( <span class="hljs-built_in">window</span>.innerWidth, <span class="hljs-built_in">window</span>.innerHeight );
                }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(camera.isPerspectiveCamera){
                    camera.aspect = <span class="hljs-built_in">window</span>.innerWidth / <span class="hljs-built_in">window</span>.innerHeight;
                    camera.updateProjectionMatrix();
                }
                renderer.setSize(<span class="hljs-built_in">window</span>.innerWidth, <span class="hljs-built_in">window</span>.innerHeight);
            };

            <span class="hljs-comment">// 材质线框</span>
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">materialWireframe</span>(<span class="hljs-params">model, isShow</span>)</span>{
                <span class="hljs-keyword">if</span>(model){
                    model.traverse(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> {
                        <span class="hljs-keyword">if</span>(child.isMesh){
                            child.material.wireframe = isShow;
                        }
                    });
                }
            }

            <span class="hljs-comment">// EdgesGeometry线框</span>
            <span class="hljs-keyword">var</span> line = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">const</span> lineMaterial = <span class="hljs-keyword">new</span> THREE.LineBasicMaterial({<span class="hljs-attr">color</span>: <span class="hljs-number">0x4080ff</span>});
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">edgeGeometryWireframe</span>(<span class="hljs-params">model, isShow</span>)</span>{
                <span class="hljs-keyword">if</span>(model){
                    <span class="hljs-keyword">if</span>(!line){
                        line = <span class="hljs-keyword">new</span> THREE.Group();
                        model.traverse(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">child</span>)</span>{
                            <span class="hljs-keyword">if</span> (child.isMesh){
                                <span class="hljs-keyword">let</span> edges = <span class="hljs-keyword">new</span> THREE.EdgesGeometry(child.geometry);
                                <span class="hljs-keyword">let</span> lineS= <span class="hljs-keyword">new</span> THREE.LineSegments(edges, lineMaterial);
                                line.add(lineS);
                            }
                        });
                        scene.add(line);
                    }
                    model.visible = !isShow;
                    line.visible = isShow;
                }
            }

            <span class="hljs-comment">// catia样式的线框</span>
            <span class="hljs-keyword">var</span> catiaLine = <span class="hljs-literal">null</span>;
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">catiaWireframe</span>(<span class="hljs-params">model, isShow</span>)</span>{
                <span class="hljs-keyword">if</span>(model){
                    <span class="hljs-keyword">if</span>(!catiaLine){
                        catiaLine = <span class="hljs-keyword">new</span> THREE.Group();
                        model.traverse(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> {
                            <span class="hljs-keyword">if</span>(child.isMesh){
                                <span class="hljs-keyword">let</span> pointIndex = fetchEdgePoint(child);
                                <span class="hljs-keyword">if</span>(pointIndex){
                                    <span class="hljs-keyword">let</span> posArr = child.geometry.attributes.position;
                                    <span class="hljs-keyword">let</span> points = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();
                                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; pointIndex.length; i += <span class="hljs-number">2</span>){
                                        <span class="hljs-keyword">let</span> k = pointIndex[i];
                                        <span class="hljs-keyword">let</span> p = pointIndex[i + <span class="hljs-number">1</span>];
                                        points.push(<span class="hljs-keyword">new</span> THREE.Vector3(posArr.getX(k), posArr.getY(k), posArr.getZ(k)));
                                        points.push(<span class="hljs-keyword">new</span> THREE.Vector3(posArr.getX(p), posArr.getY(p), posArr.getZ(p)));
                                    }
                
                                    <span class="hljs-keyword">if</span>(points.length &gt; <span class="hljs-number">0</span>){
                                        <span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> THREE.BufferGeometry().setFromPoints(points);
                                        catiaLine.add(<span class="hljs-keyword">new</span> THREE.LineSegments(geometry, <span class="hljs-keyword">new</span> THREE.LineBasicMaterial({<span class="hljs-attr">color</span>: <span class="hljs-number">0x4080ff</span>})));
                                    }
                                }
                            }
                        });
                        scene.add(catiaLine);
                    }
                    model.visible = !isShow;
                    catiaLine.visible = isShow;
                }
            }
            <span class="hljs-comment">// 边缘点探测</span>
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchEdgePoint</span>(<span class="hljs-params">mesh</span>) </span>{
                <span class="hljs-keyword">let</span> pointIndexArr = mesh.geometry.index;
                <span class="hljs-keyword">if</span>(pointIndexArr){
                    <span class="hljs-keyword">let</span> lineMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
                    <span class="hljs-keyword">let</span> indexArr = pointIndexArr.array;
                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; indexArr.length; j += <span class="hljs-number">3</span>){
                        <span class="hljs-keyword">let</span> a = indexArr[j];
                        <span class="hljs-keyword">let</span> b = indexArr[j + <span class="hljs-number">1</span>];
                        <span class="hljs-keyword">let</span> c = indexArr[j + <span class="hljs-number">2</span>];
                        <span class="hljs-keyword">let</span> temp;
                        <span class="hljs-keyword">if</span>(a &gt; b){ temp = b; b = a; a = temp; }
                        <span class="hljs-keyword">if</span>(a &gt; c){ temp = a; a = c; c = temp; }
                        <span class="hljs-keyword">if</span>(b &gt; c){ temp = b; b = c; c = temp; }

                        <span class="hljs-keyword">let</span> info = lineMap.get(a);
                        <span class="hljs-keyword">if</span>(!info){
                            info = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
                            lineMap.set(a, info);
                        }

                        <span class="hljs-keyword">let</span> co = info.get(b);
                        info.set(b, co ? co + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);
                        co = info.get(c);
                        info.set(c, co ? co + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);
                        
                        info = lineMap.get(b);
                        <span class="hljs-keyword">if</span>(!info){
                            info = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
                            lineMap.set(b, info);
                        }
                        co = info.get(c);
                        info.set(c, co ? co + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);
                    }

                    <span class="hljs-keyword">let</span> pointIndex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();
                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> [k, v] <span class="hljs-keyword">of</span> lineMap.entries()){
                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> [p, count] <span class="hljs-keyword">of</span> v.entries()){
                            <span class="hljs-keyword">if</span>(count == <span class="hljs-number">1</span>){
                                pointIndex.push(k);
                                pointIndex.push(p);
                            }
                        }
                    }

                    <span class="hljs-keyword">return</span> pointIndex;
                }
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            }

            <span class="hljs-keyword">var</span> showWireFrame = <span class="hljs-literal">false</span>;
            <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"materialBtn"</span>).addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
                showWireFrame = !showWireFrame;
                materialWireframe(model, showWireFrame);
            });

            <span class="hljs-keyword">var</span> showEdgesGeometry = <span class="hljs-literal">false</span>;
            <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"edgeBtn"</span>).addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
                showEdgesGeometry = !showEdgesGeometry;
                edgeGeometryWireframe(model, showEdgesGeometry)
            });

            <span class="hljs-keyword">var</span> showCatiaModel = <span class="hljs-literal">false</span>;
            <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"catiaBtn"</span>).addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
                showCatiaModel = !showCatiaModel;
                catiaWireframe(model, showCatiaModel);
            });
		</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"position:absolute;right:0px;bottom:0px;width: 200px; height: 100px;border-radius: 5px;background-color: rgba(255,255,255,0.6);"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"materialBtn"</span>&gt;</span>材质线框<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"edgeBtn"</span>&gt;</span>EdgesGeometry线框<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"catiaBtn"</span>&gt;</span>Catia线框<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</div></code></pre>
<blockquote>
<p>完整项目以及线上演示demo参见github: <a href="https://github.com/FrogIf/simple-threejs">simple-threejs</a></p>
</blockquote>

</body>
</html>
