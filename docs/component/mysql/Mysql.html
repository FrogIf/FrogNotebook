<!DOCTYPE html><html><head>
      <title>Mysql</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="file:///c:\Users\frogif\.vscode\extensions\shd101wyy.markdown-preview-enhanced-0.8.18\crossnote\dependencies\katex\katex.min.css">
      
      
      
      
      
      <style>
      code[class*=language-],pre[class*=language-]{color:#333;background:0 0;font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:8;-o-tab-size:8;tab-size:8;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:.8em;overflow:auto;border-radius:3px;background:#f5f5f5}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal;background:#f5f5f5}.token.blockquote,.token.comment{color:#969896}.token.cdata{color:#183691}.token.doctype,.token.macro.property,.token.punctuation,.token.variable{color:#333}.token.builtin,.token.important,.token.keyword,.token.operator,.token.rule{color:#a71d5d}.token.attr-value,.token.regex,.token.string,.token.url{color:#183691}.token.atrule,.token.boolean,.token.code,.token.command,.token.constant,.token.entity,.token.number,.token.property,.token.symbol{color:#0086b3}.token.prolog,.token.selector,.token.tag{color:#63a35c}.token.attr-name,.token.class,.token.class-name,.token.function,.token.id,.token.namespace,.token.pseudo-class,.token.pseudo-element,.token.url-reference .token.variable{color:#795da3}.token.entity{cursor:help}.token.title,.token.title .token.punctuation{font-weight:700;color:#1d3e81}.token.list{color:#ed6a43}.token.inserted{background-color:#eaffea;color:#55a532}.token.deleted{background-color:#ffecec;color:#bd2c00}.token.bold{font-weight:700}.token.italic{font-style:italic}.language-json .token.property{color:#183691}.language-markup .token.tag .token.punctuation{color:#333}.language-css .token.function,code.language-css{color:#0086b3}.language-yaml .token.atrule{color:#63a35c}code.language-yaml{color:#183691}.language-ruby .token.function{color:#333}.language-markdown .token.url{color:#795da3}.language-makefile .token.symbol{color:#795da3}.language-makefile .token.variable{color:#183691}.language-makefile .token.builtin{color:#0086b3}.language-bash .token.keyword{color:#0086b3}pre[data-line]{position:relative;padding:1em 0 1em 3em}pre[data-line] .line-highlight-wrapper{position:absolute;top:0;left:0;background-color:transparent;display:block;width:100%}pre[data-line] .line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:hsla(24,20%,50%,.08);background:linear-gradient(to right,hsla(24,20%,50%,.1) 70%,hsla(24,20%,50%,0));pointer-events:none;line-height:inherit;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{content:attr(data-start);position:absolute;top:.4em;left:.6em;min-width:1em;padding:0 .5em;background-color:hsla(24,20%,50%,.4);color:#f4f1ef;font:bold 65%/1.5 sans-serif;text-align:center;vertical-align:.3em;border-radius:999px;text-shadow:none;box-shadow:0 1px #fff}pre[data-line] .line-highlight[data-end]:after{content:attr(data-end);top:auto;bottom:.4em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ol,html body>ul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\00a0'}html body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
      <!-- The content below will be included at the end of the <head> element. --><script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function () {
    // your code here
  });
</script></head><body for="html-export">
    
    
      <div class="crossnote markdown-preview  ">
      
<h1 id="mysql学习笔记">Mysql学习笔记 </h1>
<h2 id="基础架构">基础架构 </h2>
<p><img src="img/basic_arth.png" alt="image"></p>
<blockquote>
<p>图片来源: 极客时间-Mysql实战45讲</p>
</blockquote>
<p>一下是Server层的几大模块:</p>
<ul>
<li>连接器: 连接器负责跟客户端建立连接、获取权限、维持和管理连接.
<ul>
<li>可以通过<code>show processlist</code>查看连接.</li>
<li>空闲连接时间如果超过8小时(默认), 会自动断开. 可以通过<code>wait_timeout</code>进行设置.</li>
<li>尽量使用长连接</li>
<li>长连接可能导致内存占用过大, 因为mysql执行过程中, 使用的临时内存是存储在连接对象中的. 解决方案有二: 1. 定期断开长连接; 2. 5.7及以上版本, 可以通过执行mysql_reset_connection重新初始化连接资源.</li>
</ul>
</li>
<li>查询缓存: 之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中.
<ul>
<li>查询缓存的key是查询语句</li>
<li>查询缓存的命中率很低</li>
<li>一旦表中有更新操作, 相关缓存会立即失效</li>
<li>mysql8.0以上版本移除了查询缓存</li>
</ul>
</li>
<li>分析器: 词法分析, 语法分析</li>
<li>优化器: 决定使用的索引, 确定整个sql的具体执行流程, 生成执行计划</li>
<li>执行器: 按照执行计划, 开始与存储引擎层进行交互, 执行.</li>
</ul>
<blockquote>
<p>个人理解: mysql中, 会将schema整体在内存中存储一份, 这样可供分析器, 优化器等全局使用</p>
</blockquote>
<h2 id="日志系统">日志系统 </h2>
<ul>
<li>redo log: Innodb存储引擎特有的日志系统, 通过WAL保证数据不丢失
<ul>
<li>WAL(Write-Ahead Logging)预写日志技术. 如果不使用WAL, 每次有新的数据变更, 就需要找到指定的记录, 然后执行更新操作, 这样是随机写的过程, 性能较差. 如果采用WAL, 则会先采用追加写的方式, 将数据变更保存至日志. 然后在合适的时机将数据批量同步到数据库中, 性能较好.</li>
<li>redo log默认大小为4G, 可以视作是一个环形, 采用循环写的方式, 如果已经写满, 则将其中一部分数据清除(具体看后面)</li>
<li>redo log存储的是物理日志, 记录了每个数据页修改了什么</li>
<li>redo log的主要用途是为了加快写入性能, 保证crash-safe. 具体来讲, Innodb在数据写入时, 不会直接落盘, 而是写入内存中的Buffer Pool中, 再定期同步到磁盘中. redo log就是为了保证在内存中的数据尚未同步到磁盘期间, 出现异常也可以恢复.</li>
</ul>
</li>
<li>binlog: 由执行器负责管理的日志系统, 各种不同的存储引擎共用, 用于归档
<ul>
<li>逻辑日志, 有两种记录格式: 1. statement - 记录sql; 2. row - 记录行内容(两条: 更新前/更新后); 3. mixed - 在不会引起丢失的情况下, 使用statement, 否则使用row格式;</li>
<li>binlog是用来做数据备份和数据恢复的;</li>
</ul>
</li>
</ul>
<blockquote>
<p>row格式的日志, 占用空间大, 例如, 如果条件删除, statement只需记录一条sql语句, 但是row格式需要把所有满足条件的记录都记录下来. 但是statement格式有时会导致恢复数据时存在数据丢失.</p>
</blockquote>
<p>由于存在两份日志, 分别属于不同的层面, 为了使得两份日志保持一致性, 需要采用两阶段提交:</p>
<ol>
<li>Innodb - 写入redolog, 标记状态为prepare</li>
<li>执行器 - 写入binlog</li>
<li>Innodb - 标记状态为commit</li>
</ol>
<p>数据恢复:</p>
<ul>
<li>数据恢复使用的是binlog, 而不是redolog. 首先, 数据库会有定期的全库备份, 先根据全库备份, 将数据恢复一部分. 然后, 在使用binlog, 将全库备份后又产生的数据恢复. 这个过程是手动进行的, 可以用于应对误删恢复等场景.</li>
<li>crash-safe: redolog具备crash-safe能力. 假设突然断电, 当mysql重新启动后, innodb会根据redolog把Buffer Pool中没有落盘的数据恢复. 这个过程是系统自动完成的, 使得系统具备了自愈能力. 这种场景下就不能使用binlog了, 因为如果使用binlog, 还需要手动的完成应用全量备份, 应用binlog的过程.</li>
</ul>
<blockquote>
<p>对于redolog: ElasticSearch中也有类似的角色, Segment不会立即落盘, 而是驻留在内存中, 于是为了保证数据不丢失, 有transactionLog做担保.</p>
</blockquote>
<blockquote>
<p>一次insert操作涉及的日志以及顺序: undolog --&gt; redolog(prepare) --&gt; binlog --&gt; redolog(commit)</p>
</blockquote>
<h2 id="事务">事务 </h2>
<p>事务的属性(ACID):</p>
<ul>
<li>原子性(Atomicity): 事务作为整体执行, 要么全部执行, 要么都不执行;
<ul>
<li>undo log</li>
</ul>
</li>
<li>一致性(Consistency): 事务应保证数据库的状态从一个一致状态变为另一个一致状态;
<ul>
<li>原子性+隔离性+持久性共同保障, 数据库约束</li>
</ul>
</li>
<li>隔离性(Isolation): 多个事务并发执行时, 一个事务的执行不影响其他事务的执行;
<ul>
<li>MVCC</li>
</ul>
</li>
<li>持久性(Durability): 一个事务一旦提交, 他对数据库的修改应该永久保存在数据库中.
<ul>
<li>持久化</li>
</ul>
</li>
</ul>
<p>事务的隔离级别有:</p>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>存在的问题</th>
</tr>
</thead>
<tbody>
<tr>
<td>读未提交</td>
<td>脏读, 不可重复读, 幻读</td>
</tr>
<tr>
<td>读已提交</td>
<td>不可重复读, 幻读</td>
</tr>
<tr>
<td>可重复读</td>
<td>幻读</td>
</tr>
<tr>
<td>串行化</td>
<td>-</td>
</tr>
</tbody>
</table>
<ul>
<li>脏读: 读到其它事务未提交的变更</li>
<li>不可重复度: 对某数据进行读取过程中, 有其他事务对数据进行了修改(UPDATE, DELETE), 导致第二次读取结果不同;</li>
<li>幻读: 事务在做范围查询过程中, 有另外一个事务对范围内新增或者删除记录(INSERT, DELETE), 导致范围查询的结果条数不一致;</li>
</ul>
<p>mysql默认的隔离级别是可重复读, 可以通过transaction-isolation进行修改.</p>
<p>mysql中通过多版本并发控制(MVCC, Multi-Version Concurrency Control)来实现事务隔离.</p>
<p>这里涉及到一个新的日志: undo log</p>
<p>MySQL中, 实际上每执行一条更新操作, 都会生成一条undo log. 记录上的最新值, 可以通过undo log找到前一个状态的值. 也就是说undo log中记录了数据的多个版本. undo log中如果一条回滚日志之前的所有日志都不再被视图持有的时候, 这些日志就可以删除了. 所以不要有长事务, 长事务会导致一些视图始终存在. 从而导致undo log无法删除.</p>
<ul>
<li>可重复读 - 事务启动时创建一致性视图, 整个事务过程中, 都用这个视图</li>
<li>读已提交 - 在每个sql开始执行时创建, 每一条sql执行前都会重新计算出一个视图.</li>
</ul>
<blockquote>
<p>读未提交不需要视图, 串行直接加锁</p>
</blockquote>
<p>事务MVCC一致性视图创建概述:</p>
<ol>
<li>每个事务会有一个transaction id, 这个值是严格递增;</li>
<li>每条数据更新时, 都会有一个版本id -- tx_id, 这个tx_id等于生成它的事务的transaction id;</li>
<li>数据的版本不会记录, 而是undo log中会记录从一个版本回退到前一个版本的具体细节; 在undo log中, 相当于存在一条数据的多个不同的版本;</li>
<li>一个事务启动时, 会创建一个属于它的数组, 记录当前活跃的所有事务的transaction id, 这个数组是有序的, 其最小值记为低水位, 最大值记为高水位;</li>
<li>从undo log获取到一条数据的多个tx_id.
<ul>
<li>如果tx_id小于低水位, 则该版本数据属于已提交的事务, 可见;</li>
<li>如果tx_id大于高水位, 则该版本数据属于视图创建后的事务生成的, 不可见;</li>
<li>如果tx_id在低水位和高水位之间, 则又分为两种情况: 1. tx_id在数组中, 该版本数据由未提交事务生成, 不可见; 2. tx_id不在数组中, 该版本数据由已提交事务生成, 可见;</li>
</ul>
</li>
</ol>
<h2 id="索引">索引 </h2>
<p>这里只介绍Innodb引擎的索引. Innodb引擎使用B+树来存储数据.</p>
<ul>
<li>主键索引: 主键索引的叶子节点保存了整行的数据记录. 也被称为聚簇索引.</li>
<li>非主键索引: 非主键索引的叶子节点保存了主键索引的id, 被称为二级索引.</li>
</ul>
<blockquote>
<p>这种将数据直接存储在主键索引下的叶子节点中的方式称为"索引组织表"</p>
</blockquote>
<p>添加索引的sql:</p>
<pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token keyword keyword-alter">alter</span> <span class="token keyword keyword-table">table</span> table_name <span class="token keyword keyword-add">add</span> <span class="token keyword keyword-index">index</span> index_name<span class="token punctuation">(</span>col1<span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>B+树存储的优点:</p>
<ol>
<li>B+树是多叉树, 可以有效降低树的高度.</li>
<li>每个数据页存储多个树节点, 可以有效减少访问磁盘的次数.</li>
<li>每个数据页的默认大小为16k.</li>
</ol>
<p>其他:</p>
<ul>
<li>主键索引优先使用自增主键, 这样, 插入数据的时候, 是在b+数最后进行追加, 性能好. 如果使用uuid等方式, 就会随机插入数据页中, 性能较差. 同时也可能导致插入时页分裂.</li>
<li>当一个数据页存储不下数据时, 会触发页分裂. 当存在两个数据页的利用率较低时, 会触发页合并.</li>
<li>通过二级索引查询时, 如果想获取到整条记录, 会先根据二级索引找到主键, 然后再根据主键索引查询到整条数据, 这个过程称为回表.</li>
</ul>
<p>回表会导致查询两棵索引树, 性能会有消耗, 如何避免回表:</p>
<ul>
<li>覆盖索引: 如果一个二级索引上记录的信息, 就是查询想要的全部信息, 那就不需要回表, 这称为覆盖索引.
<ul>
<li>最左匹配原则: 覆盖索引必须满足最左匹配原则, 否则就不会走索引</li>
</ul>
</li>
<li>索引下推: 在5.6开始, 推出的一项优化措施. 如果查询条件是多个时, 通过二级索引查询到主键, 当需要回表时, 会向校验这个索引中的其他数据是否与查询条件匹配, 如果不匹配, 则该条记录不会回表. 这样就减少了回表的数据记录条数.</li>
</ul>
<h4 id="索引优化">索引优化 </h4>
<ul>
<li>选错索引
<ul>
<li>通过<code>analyze table 表名</code>命令, 更新索引统计信息, 避免一些统计信息不准确导致选错索引的问题</li>
<li>通过<code>force index(索引名)</code>指示强行使用某个索引</li>
<li>删掉某些不必要的索引, 从而避免选错索引</li>
</ul>
</li>
<li>使用前缀索引
<ul>
<li>通过使用前缀索引可以减少空间使用, 增加每个数据页存储的索引个数</li>
<li>前缀索引会导致无法使用覆盖索引</li>
</ul>
</li>
</ul>
<h2 id="锁">锁 </h2>
<h4 id="全局锁">全局锁 </h4>
<p>命令: <code>flush tables with read lock</code>, 执行该命令后, 其他线程的数据更新语句, 数据定义语句, 更新类的事务提交语句都会被阻塞.</p>
<p>应用场景:</p>
<ul>
<li>全库逻辑备份: 全库逻辑备份过程中, 数据处于只读状态. 保证数据的逻辑时间点一致.</li>
</ul>
<p>全局锁是在Mysql的Server层执行的, 这样不管底层数据库执行引擎是什么, 都能使用这个工具. 但是, 全局锁导致整个数据库都处于只读状态, 大部分时候, 这显然是不可接受的. 对于Innodb引擎来说, 可以通过MVCC在事务中取得一个一致性视图, 保证数据的逻辑时间点一致.</p>
<p>全局锁还有一个特点: 加锁的这个会话中, 如果客户端意外断开, 数据库会自动释放全局锁.</p>
<h4 id="表级锁">表级锁 </h4>
<p>表级别的锁分为两种:</p>
<ol>
<li>表锁</li>
<li>元数据锁</li>
</ol>
<p>对于表锁:</p>
<p>语法: <code>lock tables ... read/write</code></p>
<ul>
<li>表锁在会话意外中断时, 也可以主动释放锁.</li>
<li>表锁不仅限制其他线程的读写, 也会限制自身线程. 如果一个线程获取到一张表的读锁, 那么只能对该表进行读操作, 不能对该表进行写操作.</li>
</ul>
<p>对于元数据锁(MDL, meta data lock):</p>
<p>元数据锁不需要显示调用:</p>
<ul>
<li>当对一个表进行增删改查时, 自动加MDL读锁</li>
<li>当对一个表结构进行变更时, 自动加MDL写锁</li>
</ul>
<blockquote>
<p>读锁之间不互斥, 因此可以有多个线程对同一张表进行增删改查; 写锁是排它锁, 只允许一个线程执行</p>
</blockquote>
<p>MDL会遇到一种情况, 是: 获取写锁后, 由于有读锁存在, 导致自身阻塞, 而这时实际上已经获取到了写锁, 进而导致新的获取读锁的线程阻塞, 最终可能引发大量线程阻塞.</p>
<h4 id="行锁">行锁 </h4>
<p>两阶段锁协议: Innodb中行锁在需要的时候加上, 在事务结束时释放.</p>
<p>当两个事务互相等待对方资源释放时, 就会出现死锁. mysql内置死锁处理措施有二:</p>
<ol>
<li>超时 - <code>innodb_lock_wait_timeout</code>, 默认50s</li>
<li>死锁检测 - <code>innodb_deadlock_detect</code>, 默认on; 死锁检测在并发线程数较多时, 性能会较低.</li>
</ol>
<p>为避免死锁, 应该在一个事务中, 把最可能造成锁冲突, 最可能影响并发度的锁尽量往后放.</p>
<blockquote>
<p>死锁日志查看:</p>
<ol>
<li>SHOW ENGINE INNODB STATUS;  查看最近一次死锁日志</li>
<li>默认情况下<code>innodb_print_all_deadlocks</code>是关闭的, 如果是开启的, 会将死锁日志输出到日志文件(通过<code>show variables like 'innodb_print_all_deadlocks';</code>查看是否开启); 开启后, 默认日志输出到<code>/var/log/mysql/error.log</code>或者通过<code>SHOW VARIABLES LIKE 'log_error'</code>;</li>
</ol>
</blockquote>
<h4 id="事务与锁-当前读">事务与锁--当前读 </h4>
<p>当前读: 更新数据都是先读后写, 而这个读, 只能读当前的值.</p>
<p>当前读的时候, 完全依赖锁, 而无视事务的隔离性了.</p>
<p>只要加锁, 就会触发当前读, 下面这三条都会使用当前读.</p>
<pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token keyword keyword-update">update</span> t <span class="token keyword keyword-set">set</span> k <span class="token operator">=</span> k <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword keyword-where">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword keyword-select">select</span> k <span class="token keyword keyword-from">from</span> t <span class="token keyword keyword-where">where</span> id<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword keyword-lock">lock</span> <span class="token operator">in</span> <span class="token keyword keyword-share">share</span> <span class="token keyword keyword-mode">mode</span><span class="token punctuation">;</span>
<span class="token keyword keyword-select">select</span> k <span class="token keyword keyword-from">from</span> t <span class="token keyword keyword-where">where</span> id<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword keyword-for">for</span> <span class="token keyword keyword-update">update</span><span class="token punctuation">;</span>
</code></pre><h4 id="间隙锁与next-key-lock">间隙锁与next-key lock </h4>
<p>innodb在可重复读级别下, 为了防止当前读时出现幻读, 会使用间隙锁(gap lock). 间隙锁是指在已存在的数据行之间添加的锁. 间隙锁的作用是: 阻塞向这个间隙中插入一个记录这个操作.</p>
<p>next-key lock是间隙锁和行锁的组合.</p>
<p>间隙锁是开区间范围上的锁, next-key lock是前开后闭区间上的锁.</p>
<p>间隙锁可能会导致锁住的范围过大, 降低了系统的并发度. 在经过评估可行的情况下, 可以选择调整为读已提交.</p>
<p>为什么间隙锁只出现在可重复度级别? 因为可重复度需要保证从事务开始到事务结束都是一致性视图, 如果出现幻读, 就会导致一致性视图存在问题. 而如果级别是读已提交, 不需要事务开始到结束都是一致性视图, 是允许幻读出现的.</p>
<blockquote>
<p>可重复读级别下, select语句并不是一定会加间隙锁的. 而是select ... for update等需要当前读的情况下才需要间隙锁.</p>
</blockquote>
<p>加锁规则:</p>
<ol>
<li>基本单位是next-key lock</li>
<li>查找过程中访问到的对象才会加锁</li>
<li>索引上的等值查询, 给唯一索引加锁时, next-key lock退化为行锁</li>
<li>索引上的等值查询, 向右遍历, 最后一个值不满足等值条件时, next-key lock退化为间隙锁</li>
<li>唯一索引上的范围查询, 会访问到不满足条件的第一个值为止</li>
</ol>
<h2 id="innodb写入流程">Innodb写入流程 </h2>
<p>以下这些概念都是Innodb的:</p>
<ul>
<li>Buffer Pool
<ul>
<li>用于存储运行期间, 加载到内存中的数据页</li>
<li>在更新一条记录时, 如果数据页已经加载到Buffer Pool中, 则直接更新Buffer Pool中的数据页</li>
<li>更新后的数据页如果没有同步到磁盘中, 则称为脏页</li>
</ul>
</li>
<li>Change Buffer
<ul>
<li>Buffer Pool中的一块特殊区域, 不用来存储数据页, 而是用来存储数据变更动作(类似于redo log)</li>
<li>在更新一条记录时, 如果数据页没有加载到Buffer Pool中, 则直接将这个变更动作存储到Change Buffer, 免去了从磁盘读取数据页的操作</li>
<li>Change Buffer也会单独被持久化到磁盘上</li>
<li>innodb_change_buffer_max_size, 用来控制change buffer在buffer pool中的占比</li>
</ul>
</li>
<li>Merge
<ul>
<li>将Change Buffer中的变更记录应用到数据页的过程称为Merge</li>
<li>一旦由于查询等操作, 导致数据页被加载到内存, 就会触发Merge操作</li>
<li>系统会定期执行Merge操作</li>
<li>数据库正常关闭时, 会执行merge操作</li>
</ul>
</li>
<li>Redo log
<ul>
<li>redo log用来对Buffer Pool中的脏页和Change Buffer做crash-safe担保, 一旦发生异常, 导致脏页和ChangeBuffer丢失, 可以通过redo log恢复</li>
</ul>
</li>
<li>Flush
<ul>
<li>将内存中的脏页同步至磁盘的过程称为Flush</li>
<li>Flush触发时机:
<ul>
<li>当redo log写满了, 清除一部分redolog时
<ul>
<li>此时触发flush, 会使得系统不再接受更新操作, 所有更新都会阻塞</li>
</ul>
</li>
<li>当Buffer Pool快满的时候, <code>innodb_max_dirty_pages_pct</code>控制脏页比例上限</li>
<li>当mysql比较空闲时</li>
<li>mysql正常关闭时</li>
</ul>
</li>
<li>通过<code>innodb_io_capacity</code>参数, 告诉mysql当前磁盘的io读写能力, 使得其可以参照该能力去进行flush. 一般这个值可以设置成磁盘的IOPS</li>
<li>flush过程中, 不需要redo log同步变更, redo log重放的过程值, 可以识别出来哪些数据页是刷过的.</li>
<li>当刷新脏页时, 连续的多个脏页都会被flush. 对于机械硬盘, 这是有好处的, 但是对于固态硬盘, 这样就没有必要了, 可以通过<code>innodb_flush_neighbors</code>控制, 当该值为0时, 则只刷新自己</li>
</ul>
</li>
</ul>
<blockquote>
<p>在读多写少的一些场景中, 由于数据页会频繁的被加载至内存中, 所以没有必要使用ChangeBuffer, 反而增加了ChangeBuffer维护成本<br>
在对唯一索引字段上的数据进行修改时, 不会使用到change buffer, 这是因为需要先将数据页加载到Buffer Pool用以验证唯一性约束是否满足.</p>
</blockquote>
<h2 id="排序">排序 </h2>
<p>排序主体流程:</p>
<ol>
<li>将符合条件的记录加载至sort buffer, sort buffer是线程私有的, <code>sort_buffer_size</code>控制这块内存区域的大小;</li>
<li>如果加载的记录占用空间超出sort buffer, 则需要转至文件中, 使用磁盘的临时辅助文件进行排序;</li>
<li>如果使用磁盘进行辅助排序, 排序过程是将数据拆分成多个辅助文件, 每一次将一个辅助文件加载至内存进行排序; 最后再把排序后的文件多个文件整体归并.</li>
</ol>
<p>上面这个排序过程为: <strong>filesort</strong> 即使不需要转至磁盘, 也叫filesort.</p>
<p>此外, 排序有分为两种:</p>
<ol>
<li>全字段排序 - 加载到sort buffer的是需要返回给客户端的全部字段;</li>
<li>rowid排序 - 加载到sort buffer的数据只有主键id和参与排序的字段, 在排序完成之后, 需要回表将其他需要的字段补充完整.</li>
</ol>
<blockquote>
<p>通过配置<code>max_length_for_sort_data</code>, 可以控制使用哪种排序方式, 如果单行数据尺寸超出这个值, 就被视为单行太大, 从而使用rowid.</p>
</blockquote>
<p>如果排序字段上存在索引, 则不需要上面的排序了, 因为这时的数据本身就是有序的.</p>
<h2 id="关联查询">关联查询 </h2>
<p>关联查询join, 在mysql中存在几种不同的关联查询方式:</p>
<ul>
<li>Index Nested-Loop Join: 先全量扫描驱动表, 扫描过程中, 根据每条记录结果, 通过被驱动表的索引树, 获取被驱动表关联记录
<ul>
<li>驱动表会进行全表扫描, 被驱动表直接走索引</li>
</ul>
</li>
<li>Block Nested-Loop Join: 直接获取驱动表的结果集, 放入join buffer, 扫描被驱动表, 把满足条件的放入结果集返回
<ul>
<li>驱动表和被驱动表都做了一次全表扫描</li>
<li>join buffer有大小限制, 默认256k. 如果放不下, 就先拿一部分驱动表的数据放入join buffer然后匹配结果直接返回, 然后再拿一部分再匹配, 直到完成遍历. 这样就会导致被驱动表反复进行多次全表扫描.</li>
</ul>
</li>
</ul>
<p>不论在NLJ还是BNL中, 都应该尽可能使用小表作为驱动表. 关联查询时, 尽可能使用索引.</p>
<p>Multi-Range Read优化:</p>
<p>这个单纯是查询优化, 并不是只针对关联查询. 首先依据是: 读取数据时, 如果是范围查询, 按照顺序, 依次读取要比随机读取性能好. 例如, in查询, in里边如果可以走索引, 那么在索引树上就是天然有序的, 那么就可以将in中的元素排序, 然后在查询索引树. 这就是MRR.</p>
<p>Batched Key Access优化;</p>
<p>这个是通过MRR, 对NLJ进行的优化. 上面介绍, 全量扫描驱动表, 然后一条一条的查询被驱动表的索引树, 可以优化为将驱动表查询得到的结果排序, 然后批量的查询被驱动表的索引树. 这就是BKA. 另外BKA存储批量查询条件的地方就是join buffer.</p>
<p>BNL算法对系统的主要影响:</p>
<ol>
<li>可能会多次扫描被驱动表，占用磁盘 IO 资源;</li>
<li>判断 join 条件需要执行 M*N 次对比（M、N 分别是两张表的行数），如果是大表就会占用非常多的 CPU 资源；</li>
<li>可能会导致 Buffer Pool 的热数据被淘汰，影响内存命中率。</li>
</ol>
<h2 id="其他">其他 </h2>
<ul>
<li>数据库中删除一条记录, 只是将数据页中该记录的空间标记为可复用. 这样久而久之产生很多"空洞";</li>
<li>innodb引擎中, 处于MVCC考虑, <code>count(*)</code>会进行全表扫描;</li>
<li>查询条件, 对索引字段做函数操作, 会破坏索引值的有序性, 因此优化器会放弃走索引树;</li>
<li>mysql中, 如果字符串和数字进行比较, 会将字符串转为数字;</li>
</ul>
<h4 id="查询慢的一些场景">查询慢的一些场景 </h4>
<ul>
<li>MDL导致, 通过<code>show processlist</code>查看线程状态;</li>
<li>行锁导致, 一个查询使用的当前读, 遇到另一个线程持有行锁. 通过<code>select * from sys.innodb_lock_waits where locked_table = 'test.t'</code>找到持有锁的线程</li>
<li>一致性读的情况下, 有可能一条数据的活跃版本太多, 导致通过undo log回溯的链条太长, 导致查询慢</li>
</ul>
<h4 id="表空间">表空间 </h4>
<ul>
<li>系统表空间: 用于存放系统信息, 对应磁盘文件<code>ibdata1</code></li>
<li>数据表空间: 用于存放用户数据, 对应磁盘文件<code>表名.ibd</code></li>
</ul>
<h4 id="执行计划">执行计划 </h4>
<pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword keyword-explain">explain</span> <span class="token keyword keyword-select">select</span> <span class="token operator">*</span> <span class="token keyword keyword-from">from</span> city<span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword keyword-table">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword keyword-type">type</span> <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword keyword-key">key</span>  <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token keyword keyword-rows">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword keyword-SIMPLE">SIMPLE</span>      <span class="token operator">|</span> city  <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword keyword-ALL">ALL</span>  <span class="token operator">|</span> <span class="token boolean">NULL</span>          <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token number">1</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>  <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span>
</code></pre><ul>
<li>select type : 表示select类型, 常见取值如下:
<ul>
<li>simple : 简单表, 不使用表连接和子查询的查询</li>
<li>primary : 主查询, 即外层查询</li>
<li>union : union关键字后面的查询</li>
<li>subquery : 子查询中的第一个select</li>
</ul>
</li>
<li>table : 查询的表</li>
<li>partitions : 查询的分区</li>
<li>type : 访问类型: 性能由好到差排列如下:
<ul>
<li>null: 查询语句没有表时;</li>
<li>system: 访问系统表;</li>
<li>const: 查询使用主键聚集索引或者唯一索引;</li>
<li>eq_ref : 使用唯一索引扫描, 出现在多表连接使用primary key或者unique index作为关联条件的查询中;</li>
<li>ref : 使用非唯一索引或者前缀索引扫描, 返回匹配某个单独值的记录. ref还常出现于join中.</li>
<li>range : 局部索引扫描, 常见于&lt;, &lt;=, &gt;, &gt;=, between等查询.</li>
<li>index : 用了索引, 但是遍历了整个索引树;</li>
<li>all : 全表扫描</li>
</ul>
</li>
<li>possible_key : 查询中可能使用的索引</li>
<li>key : 实际使用的索引</li>
<li>key_len : 使用到索引字段的长度</li>
<li>rows : 扫描的行数</li>
<li>filtered : 预估一个符合条件的行数占表中总行数的百分比.</li>
<li>Extra : 执行情况的额外说明. 也很重要:
<ul>
<li>using index condition : 索引下推(ICP, index condition pushdown)</li>
<li>using index : 覆盖索引, 不需要回表</li>
<li>using where : 使用where过滤了一部分条件(不一定回表)</li>
<li>using temporary : 使用了临时表. 经常发生在存在Group By和Order by子句, 但是两个子句中使用的列不同的情况</li>
<li>Using filesort : 文件排序. 当查询中存在order by子句, 并且无法通过索引完成排序, 只能全表扫描, 然后存储排好序的键, 然后根据键检索出行.</li>
</ul>
</li>
</ul>
<blockquote>
<p>type类型还有一些:<br>
ref_or_null: 和ref相似, 区别在于条件中包含对null的查询.<br>
index_merge: 索引合并优化<br>
unique_subquery : in的后面是一个查询主键字段的子查询<br>
index_subquery : in后面是查询非唯一索引字段的子查询</p>
</blockquote>
<h4 id="主从复制">主从复制 </h4>
<p>MySQL主从复制时基于binlog实现的. 大致流程如下:</p>
<img src="img/mysql_data_sync.png" height="300px">
<h2 id="场景应用">场景应用 </h2>
<h4 id="热点数据更新">热点数据更新 </h4>
<p>Mysql层面如何应对热点数据频繁更新?</p>
<ol>
<li>数据分桶: 将一大批数据拆分成多个小数据, 分别在不同的桶中执行;</li>
<li>合并请求: 多次更新操作合并为一个, 进行批量更新;</li>
<li>改造Mysql底层</li>
</ol>
<h4 id="自增主键用尽了">自增主键用尽了 </h4>
<ul>
<li>对于自定义的主键, 自增主键用尽之后, 新插入数据时, 主键不会自增, 进而导致报主键冲突;</li>
<li>对于不是自定义的主键, mysql会自己创建一个隐式主键<code>row_id</code>, 这时如果用尽了, 会从0开始重新自增, 这时即使原来已经有<code>row_id</code>为0的数据, 也不会报主键重复, 而是直接覆盖这条数据;</li>
</ul>
<p>解决办法:</p>
<ul>
<li>如果原来是int, 改成bigint就可以了;</li>
<li>如果原始是bigint, 那么建议将旧数据归档到另一个表, 然后再利用释放出来的主键;</li>
</ul>
<h4 id="like模糊查询优化">like模糊查询优化 </h4>
<p>对于<code>abc%</code>查询, 可以直接走索引, 就不需要考虑啥优化了; 对于<code>%abc</code>如何优化呢? 可以这样: 新建一个列, 保存原始字符串值的倒序, 然后查询的时候, 这样查: <code>like 'cba%'</code>.</p>
<blockquote>
<p>在MySQL5.7.6之后, 新增了虚拟列, 可以直接使用虚拟列实现这一点;<br>
alter table xxx add column v_column varchar(50) generated always as (reverse(<code>name</code>)) virtual;  // 创建虚拟列<br>
alter table xxx add index idx_name_virt (v_name); // 为虚拟列创建索引</p>
</blockquote>
<h4 id="数据库加密后模糊查询">数据库加密后模糊查询 </h4>
<ol>
<li>对于加密时候使用的是数据库加密函数进行加密的情况, 这时模糊查询可以使用解密函数解密后查询;</li>
<li>明文分词: 将字符串分词之后, 再分别加密, 然后再拼接后存入数据库. 查询时, 也是先分词, 再加密, 再拼接, 再查询;</li>
</ol>
<h4 id="不建议使用外键">不建议使用外键 </h4>
<p>阿里开发手册中指出: 不得使用外键与级联, 一切外键概念必须在应用层解决;</p>
<p>使用外键会带来的问题:</p>
<ol>
<li>性能问题: 每次增改删都需要做外键约束检查;</li>
<li>锁竞争问题: 有外键约束, 就会导致有时需要用到额外的锁;</li>
<li>无法适应分库分表</li>
<li>逻辑删除: 业务中经常使用的是逻辑删除, 有外键会导致这种删除很麻烦;</li>
</ol>
<h4 id="deletedroptruncate">DELETE/DROP/TRUNCATE </h4>
<ul>
<li>DELETE基于行的删除;</li>
<li>TRUNCATE用于快速删除表中所有记录, 并重置任何自增的计数器;</li>
<li>DROP用于删除整个表结构;</li>
</ul>
<h2 id="常用命令">常用命令 </h2>
<ul>
<li>登录mysql</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>./mysql -h127.0.0.1 -P3306 -uaaa -p
</code></pre><pre data-role="codeBlock" data-info="" class="language-text"><code>show databases;

use xxdatabaseName;
</code></pre><h2 id="reference">Reference </h2>
<ul>
<li>极客时间-MySQL实战45讲</li>
</ul>

      </div>
      
      
    
    
    
    
    
    
  
    </body></html>