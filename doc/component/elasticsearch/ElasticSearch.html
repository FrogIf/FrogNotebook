<!DOCTYPE html>
<html>
<head>
<title>ElasticSearch.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h2 id="%E6%A6%82%E8%BF%B0">概述</h2>
<p><strong>特性</strong></p>
<ul>
<li>Kibana
<ul>
<li>可视化分析</li>
</ul>
</li>
<li>Elasticsearch</li>
<li>Logstash
<ul>
<li>数据处理管道
<ul>
<li>实时解析转换数据</li>
<li>敏感字段排除</li>
<li>等等...存在多个插件</li>
</ul>
</li>
</ul>
</li>
<li>Beats
<ul>
<li>轻量的数据采集器
<ul>
<li>FileBeat - 日志文件</li>
<li>PacketBeat - 网络数据抓包</li>
</ul>
</li>
</ul>
</li>
<li>日志管理
<ul>
<li>
<ol>
<li>日志搜集</li>
</ol>
</li>
<li>
<ol start="2">
<li>格式化分析</li>
</ol>
</li>
<li>
<ol start="3">
<li>全文检索</li>
</ol>
</li>
<li>
<ol start="4">
<li>风险告警</li>
</ol>
</li>
<li>整体流程: beats --&gt; redis/kafka/rabbitMQ(当数据量较大时, 可以使用这些组件作为缓冲) --&gt; logstash --&gt; elasticsearch --&gt; kibana</li>
</ul>
</li>
<li>elasticsearch&amp;数据
<ul>
<li>单独使用elasticsearch存储</li>
<li>与数据库进行集成
<ul>
<li>与现有系统集成</li>
<li>考虑事务性</li>
<li>数据更新频繁</li>
</ul>
</li>
</ul>
</li>
<li>插件
<ul>
<li>分词插件</li>
<li>其他插件</li>
<li>手动安装</li>
</ul>
</li>
</ul>
<p><strong>基本概念</strong></p>
<ul>
<li>文档
<ul>
<li>可以被搜索的最小数据单元</li>
<li>元数据
<ul>
<li>index_  -- 文档所属索引</li>
<li>_id -- 文档唯一id</li>
<li>_source -- 文档原始json数据</li>
<li>_score -- 在一次查询中的具体算分</li>
</ul>
</li>
</ul>
</li>
<li>索引
<ul>
<li>一类相似文档的集合</li>
<li>index -- 逻辑概念 -- Mapping -- 文档字段定义</li>
<li>shard -- 物理概念 -- 索引中的数据被分散到多个shard上 -- setting -- 定义不同的数据分布</li>
</ul>
</li>
<li>节点</li>
<li>集群</li>
<li>分片</li>
<li>倒排索引
<ul>
<li>单词词典 -- 记录所有文档的单词, 记录单词到倒排列表的关联关系</li>
<li>倒排列表 -- 倒排索引项
<ul>
<li>文档id</li>
<li>词频 -- 该单词在文档中出现的次数, 用于相关性评分</li>
<li>位置(Position) -- 单词在文档中分词位置, 用于语句搜索</li>
<li>偏移(Offset) -- 记录单词开始结束位置, 实现高亮显示</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="doc%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5">doc的增删改查</h2>
<ul>
<li>Create创建一个新的文档, 如果id存在, 会失败, 亦可以不指定id, 会自动生成id</li>
</ul>
<pre class="hljs"><code><div>PUT my_index/_create/1
{
    &quot;user&quot;:&quot;mine&quot;,
    &quot;comment&quot;:&quot;xxxx&quot;
}
</div></code></pre>
<p>让系统自动生成id(注意, 这里必须是POST, 如果后面跟着id, 则可以是PUT):</p>
<pre class="hljs"><code><div>POST my_index/_doc
{
    &quot;user&quot;:&quot;mine&quot;,
    &quot;comment&quot;:&quot;xxxx&quot;
}
</div></code></pre>
<p>Index创建一个新的文档, 如果id不存在, 创建新的文档, 否则删除现有文档, 再创建新的文档, 同时版本号加1</p>
<pre class="hljs"><code><div>PUT my_index/_doc/1
{
    &quot;user&quot;:&quot;mine&quot;,
    &quot;comment&quot;:&quot;xxxx&quot;
}
</div></code></pre>
<ul>
<li>查询一个文档, 找不到返回404</li>
</ul>
<pre class="hljs"><code><div>GET my_index/_doc/1
</div></code></pre>
<ul>
<li>Update文档, 文档必须已经存在, 更新志会对响应字段做增改</li>
</ul>
<pre class="hljs"><code><div>POST my_index/_update/1
{
    &quot;doc&quot;:{
        &quot;user&quot;:&quot;mike&quot;,
        &quot;comment&quot;:&quot;you know&quot;
    }
}
</div></code></pre>
<ul>
<li>Delete文档</li>
</ul>
<pre class="hljs"><code><div>DELETE my_index/_doc/1
</div></code></pre>
<pre class="hljs"><code><div>// create document. 自动生成id
POST users/_doc
{
  &quot;user&quot;:&quot;Mike&quot;,
  &quot;post_date&quot;: &quot;2021-05-23T15:55:00&quot;,
  &quot;message&quot;: &quot;trying out kibana&quot;
}

// create document. 指定id, 如果id已存在, 报错
PUT users/_doc/1?op_type=create
{
  &quot;user&quot;:&quot;Jack&quot;,
  &quot;post_date&quot;: &quot;2021-05-23T15:55:00&quot;,
  &quot;message&quot;: &quot;trying out ElasticSearch&quot;
}

// 通过id获取文档
GET users/_doc/1

// index document.
PUT users/_doc/1
{
  &quot;users&quot;:&quot;Mike&quot;
}

// update document
POST users/_update/1
{
  &quot;doc&quot;:{
    &quot;post_date&quot;: &quot;2021-05-23T15:55:00&quot;,
    &quot;message&quot;: &quot;trying out ElasticSearch&quot;
  }
}
</div></code></pre>
<ul>
<li>Bulk批量操作, 一次api调用对不同的索引进行操作, 支持四种类型操作: index, create, update, delete</li>
</ul>
<p>单条失败不会影响其他操作</p>
<pre class="hljs"><code><div>POST _bulk
{ &quot;index&quot;: { &quot;_index&quot;:&quot;test&quot;,&quot;_id&quot;:&quot;1&quot; } }
{ &quot;field1&quot;:&quot;value1&quot; }
{ &quot;delete&quot;:{ &quot;_index&quot;:&quot;test&quot;, &quot;_id&quot;:&quot;2&quot;} }
{ &quot;create&quot;:{ &quot;_index&quot;: &quot;test2&quot;, &quot;_id&quot;:&quot;3&quot; } }
{ &quot;field1&quot;:&quot;value3&quot; }
{ &quot;update&quot;:{ &quot;_id&quot;:&quot;1&quot;, &quot;_index&quot;:&quot;test&quot; } }
{ &quot;doc&quot;:{ &quot;field2&quot;:&quot;value2&quot; } }
</div></code></pre>
<ul>
<li>mget批量读取</li>
</ul>
<pre class="hljs"><code><div>GET _mget
{
  &quot;docs&quot;:[
      {
        &quot;_index&quot;:&quot;test&quot;,
        &quot;_id&quot;:1
      },
      {
        &quot;_index&quot;: &quot;test&quot;,
        &quot;_id&quot;:2
      }
    ]
}
</div></code></pre>
<ul>
<li>msearch</li>
</ul>
<pre class="hljs"><code><div>POST test/_msearch
{}
{&quot;query&quot;:{&quot;match_all&quot;:{}}, &quot;size&quot;:1}
{&quot;index&quot;:&quot;test2&quot;}
{&quot;query&quot;:{&quot;match_all&quot;:{}}}
</div></code></pre>
<h2 id="%E5%88%86%E8%AF%8D">分词</h2>
<ul>
<li>Analysis
<ul>
<li>文本分析, 把全文本转换为一系列单词的过程, 也叫分词</li>
<li>分词器(Analyzer)
<ul>
<li>CharacterFilters -- 针对原始文本处理 -- 去除html等</li>
<li>Tokenizer -- 按照规则切分单词</li>
<li>TokenFilter -- 将切分的单词进行加工
<ul>
<li>转小写</li>
<li>删除stop word</li>
<li>增加同义词</li>
</ul>
</li>
</ul>
</li>
<li>Analyzer实例
<ul>
<li>Standard Analyzer
<ul>
<li>Tokenizer
<ul>
<li>standard -- 按词切分</li>
</ul>
</li>
<li>TokenFilters
<ul>
<li>Standard</li>
<li>LowerCase -- 小写处理</li>
<li>Stop(默认关闭) -- 停用词</li>
</ul>
</li>
</ul>
</li>
<li>Simple Analyzer
<ul>
<li>Tokenizer
<ul>
<li>LowerCase -- 按照非字母切分, 非字母都被去除, 小写处理</li>
</ul>
</li>
</ul>
</li>
<li>Whitespace Analyzer
<ul>
<li>Tokenizer
<ul>
<li>whitespace -- 按照空格切分</li>
</ul>
</li>
</ul>
</li>
<li>Stop Analyzer
<ul>
<li>Tokenizer
<ul>
<li>LowerCase -- 按照非字母切分, 非字母都被去除, 小写处理</li>
</ul>
</li>
<li>TokenFilters
<ul>
<li>Stop -- 删除停用词</li>
</ul>
</li>
</ul>
</li>
<li>Keyword Analyzer
<ul>
<li>Tokenizer
<ul>
<li>keyword -- 不分词, 直接将输入当做term输出</li>
</ul>
</li>
</ul>
</li>
<li>Pattern Analyzer
<ul>
<li>Tokenizer
<ul>
<li>Pattern -- 通过正则进行分词, 默认是\w+正则</li>
</ul>
</li>
<li>TokenFilters
<ul>
<li>LowerCase -- 小写处理</li>
</ul>
</li>
</ul>
</li>
<li>English Analyzer</li>
<li>ICU Analyzer</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div># 直接指定analyzer进行测试
GET /_analyze
{
  &quot;analyzer&quot;: &quot;standard&quot;,
  &quot;text&quot;:&quot;Mastering ElasticSearch, elastissearch in Action&quot;
}

# 指定索引字段, 自动根据该字段的分词器进行测试
POST users/_analyze
{
  &quot;field&quot;:&quot;message&quot;,
  &quot;text&quot;: &quot;Mastering ElasticSearch&quot;
}

# 自定义分词器进行测试
POST /_analyze
{
  &quot;tokenizer&quot;: &quot;standard&quot;,
  &quot;filter&quot;: [&quot;lowercase&quot;],
  &quot;text&quot;: &quot;Mastering ElasticSearch&quot;
}
</div></code></pre>
<pre class="hljs"><code><div># standard analyzer
GET _analyze
{
  &quot;analyzer&quot;: &quot;standard&quot;,
  &quot;text&quot;: &quot;2 running Quick brown-foxes leap over lazy dogs in the summer evening&quot;
}

# simple analyzer
GET _analyze
{
  &quot;analyzer&quot;: &quot;simple&quot;,
  &quot;text&quot;: &quot;2 running Quick brown-foxes leap over lazy dogs in the summer evening&quot;
}

# whitespace analyzer
GET _analyze
{
  &quot;analyzer&quot;: &quot;whitespace&quot;,
  &quot;text&quot;: &quot;2 running Quick brown-foxes leap over lazy dogs in the summer evening&quot;
}


# stop analyzer 
GET _analyze
{
  &quot;analyzer&quot;: &quot;stop&quot;,
  &quot;text&quot;: &quot;2 running Quick brown-foxes leap over lazy dogs in the summer evening&quot;
}

# keyword analyzer 
GET _analyze
{
  &quot;analyzer&quot;: &quot;keyword&quot;,
  &quot;text&quot;: &quot;2 running Quick brown-foxes leap over lazy dogs in the summer evening&quot;
}

# pattern analyzer 
GET _analyze
{
  &quot;analyzer&quot;: &quot;pattern&quot;,
  &quot;text&quot;: &quot;2 running Quick brown-foxes leap over lazy dogs in the summer evening&quot;
}

# english analyzer 
GET _analyze
{
  &quot;analyzer&quot;: &quot;english&quot;,
  &quot;text&quot;: &quot;2 running Quick brown-foxes leap over lazy dogs in the summer evening&quot;
}

# standard analyzer 对中文处理
GET _analyze
{
  &quot;analyzer&quot;: &quot;standard&quot;,
  &quot;text&quot;:&quot;他说的的确在理&quot;
}

# icu analyzer 对中文处理
GET _analyze
{
  &quot;analyzer&quot;: &quot;icu_analyzer&quot;,
  &quot;text&quot;:&quot;他说的的确在理&quot;
}
</div></code></pre>
<pre class="hljs"><code><div># 去除html标签, 不分词
POST _analyze
{
  &quot;char_filter&quot;: [&quot;html_strip&quot;],
  &quot;tokenizer&quot;: &quot;keyword&quot;,
  &quot;text&quot;: &quot;&lt;b&gt;hello world&lt;/b&gt;&quot;
}

# 使用character filter进行替换
POST _analyze
{
  &quot;char_filter&quot;: [
    {
      &quot;type&quot;: &quot;mapping&quot;,
      &quot;mappings&quot;: [&quot;- =&gt; _&quot;]
    }
  ],
  &quot;tokenizer&quot;: &quot;standard&quot;,
  &quot;text&quot;: &quot;123-456, I-test! test-900 650-234-2733&quot;
}

# character filter表情替换
POST _analyze
{
  &quot;char_filter&quot;: [
    {
      &quot;type&quot;: &quot;mapping&quot;,
      &quot;mappings&quot;: [&quot;:) =&gt; happy&quot;, &quot;:( =&gt; sad&quot;]
    }
  ],
  &quot;tokenizer&quot;: &quot;standard&quot;,
  &quot;text&quot;: [
    &quot;I am felling :)&quot;,
    &quot;Feeling :( today&quot;
  ]
}

# 正则character filter
POST _analyze
{
  &quot;char_filter&quot;: [
    {
      &quot;type&quot;: &quot;pattern_replace&quot;,
      &quot;pattern&quot;: &quot;http://(.*)&quot;,
      &quot;replacement&quot;: &quot;$1&quot;
    }
  ],
  &quot;tokenizer&quot;: &quot;standard&quot;,
  &quot;text&quot;: &quot;http://www.elastic.com&quot;
}

# 按照文件路径进行分词
POST _analyze
{
  &quot;tokenizer&quot;: &quot;path_hierarchy&quot;,
  &quot;text&quot;: &quot;/user/ymruan/a/b/c/d/e&quot;
}

# 分词, 去除停用词
POST _analyze
{
  &quot;tokenizer&quot;: &quot;whitespace&quot;,
  &quot;filter&quot;: [&quot;stop&quot;],
  &quot;text&quot;: &quot;The rain in Spain falls mainly on the plain.&quot;
}

# 分词, 转小写, 去除停用词
POST _analyze
{
  &quot;tokenizer&quot;: &quot;whitespace&quot;,
  &quot;filter&quot;: [&quot;lowercase&quot;, &quot;stop&quot;],
  &quot;text&quot;: &quot;The rain in Spain falls mainly on the plain.&quot;
}
</div></code></pre>
<pre class="hljs"><code><div># 为索引指定自定义分词
PUT my_index
{
  &quot;settings&quot;:{
    &quot;analysis&quot;: {
      &quot;analyzer&quot;: {
        &quot;my_customer_analyzer&quot;: {
          &quot;type&quot;: &quot;custom&quot;,
          &quot;char_filter&quot;:[
            &quot;emoticons&quot;
          ],
          &quot;tokenizer&quot;: &quot;punctuation&quot;,
          &quot;filter&quot;: [
            &quot;lowercase&quot;,
            &quot;english_stop&quot;
          ]
        }
      },
      &quot;tokenizer&quot;: {
        &quot;punctuation&quot;:{
          &quot;type&quot;: &quot;pattern&quot;,
          &quot;pattern&quot;: &quot;[ .,!?]&quot;
        }
      },
      &quot;char_filter&quot;: {
        &quot;emoticons&quot;: {
          &quot;type&quot;: &quot;mapping&quot;,
          &quot;mappings&quot;: [
            &quot;:) =&gt; happy&quot;,
            &quot;:( =&gt; sad&quot;
          ]
        }
      },
      &quot;filter&quot;: {
        &quot;english_stop&quot;:{
          &quot;type&quot;: &quot;stop&quot;,
          &quot;stopwords&quot;: &quot;_english_&quot;
        }
      }
    }
  }
}

POST my_index/_analyze
{
  &quot;analyzer&quot;: &quot;my_customer_analyzer&quot;,
  &quot;text&quot;: &quot;I'm a :) person, and you?&quot;
}
</div></code></pre>
<h2 id="mapping">Mapping</h2>
<ul>
<li>定义索引中字段的名称</li>
<li>定义字段的数据类型
<ul>
<li>简单类型
<ul>
<li>Text/Keyword</li>
<li>Date</li>
<li>Integer/Floating</li>
<li>Boolean</li>
<li>IPv4/IPv6</li>
</ul>
</li>
<li>复杂类型
<ul>
<li>对象类型/嵌套类型</li>
</ul>
</li>
<li>特殊类型
<ul>
<li>geo_point &amp; geo_shape / percolator</li>
</ul>
</li>
</ul>
</li>
<li>字段, 倒排索引的相关配置(Analyzed or Not Analyzed, Analyzer)</li>
<li>Dynamic Mapping</li>
<li>是否允许更改Mapping字段的类型
<ul>
<li>新增字段
<ul>
<li>Dynamic设置为true时, 一旦有新增字段写入文档, Mapping也同时给更新</li>
<li>Dynamic设置为false时, Mapping不会被更新, 新增字段的数据无法被索引, 但是信息会出现在_source中</li>
<li>Dynamic设置为Strict, 文档写入失败</li>
</ul>
</li>
<li>对于已有字段, 一旦已经有数据写入, 就不在支持修改字段定义</li>
<li>如果希望修改字段类型, 必须ReindexAPI重建索引</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>PUT mapping_test/_doc/1
{
  &quot;firstName&quot;:&quot;Chan&quot;,
  &quot;lastName&quot;:&quot;Jackie&quot;,
  &quot;loginDate&quot;:&quot;2021-05-24T20:43:00.103Z&quot;
}

GET mapping_test/_mapping

DELETE mapping_test

PUT mapping_test/_doc/1
{
  &quot;uid&quot;:&quot;123&quot;,
  &quot;isVip&quot;:false,
  &quot;isAdmin&quot;:&quot;true&quot;,
  &quot;age&quot;:19,
  &quot;heigh&quot;:180
}

GET mapping_test/_doc/1

GET mapping_test/_mapping

PUT dynamic_mapping_test/_doc/1
{
  &quot;newField&quot;:&quot;someValue&quot;
}

POST dynamic_mapping_test/_search
{
  &quot;query&quot;:{
    &quot;match&quot;:{
      &quot;newField&quot;:&quot;someValue&quot;
    }
  }
}

PUT dynamic_mapping_test/_mapping
{
  &quot;dynamic&quot;:false
}

PUT dynamic_mapping_test/_doc/10
{
  &quot;anotherField&quot;:&quot;someValue&quot;
}

GET dynamic_mapping_test/_mapping

PUT dynamic_mapping_test/_mapping
{
  &quot;dynamic&quot;:&quot;strict&quot;
}

PUT dynamic_mapping_test/_doc/11
{
  &quot;lastField&quot;:&quot;value&quot;
}

DELETE dynamic_mapping_test
</div></code></pre>
<p>手动指定mapping</p>
<pre class="hljs"><code><div>DELETE users

# 指定mobile字段不被索引
PUT users
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;firstName&quot;:{
        &quot;type&quot;:&quot;text&quot;
      },
      &quot;lastName&quot;:{
        &quot;type&quot;:&quot;text&quot;
      },
      &quot;mobile&quot;:{
        &quot;type&quot;:&quot;text&quot;,
        &quot;index&quot;: false
      }
    }
  }
}

PUT users/_doc/1
{
  &quot;firstName&quot;:&quot;Ruan&quot;,
  &quot;lastName&quot;:&quot;Yiming&quot;,
  &quot;mobile&quot;:&quot;12345678&quot;
}

POST users/_search
{
  &quot;query&quot;: {
    &quot;match&quot;:{
      &quot;mobile&quot;:&quot;12345678&quot;
    }
  }
}

DELETE users

# 空值设置
PUT users
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;firstName&quot;:{
        &quot;type&quot;:&quot;text&quot;
      },
      &quot;lastName&quot;:{
        &quot;type&quot;:&quot;text&quot;
      },
      &quot;mobile&quot;:{
        &quot;type&quot;:&quot;keyword&quot;,
        &quot;null_value&quot;: &quot;NULL&quot;
      }
    }
  }
}

PUT users/_doc/1
{
  &quot;firstName&quot;:&quot;Ruan&quot;,
  &quot;lastName&quot;:&quot;Yiming&quot;,
  &quot;mobile&quot;:null
}

POST users/_search
{
  &quot;query&quot;: {
    &quot;match&quot;:{
      &quot;mobile&quot;:&quot;NULL&quot;
    }
  }
}

DELETE users

# copy to 
PUT users
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;firstName&quot;:{
        &quot;type&quot;:&quot;text&quot;,
        &quot;copy_to&quot;: &quot;fullName&quot;
      },
      &quot;lastName&quot;:{
        &quot;type&quot;:&quot;text&quot;,
        &quot;copy_to&quot;: &quot;fullName&quot;
      }
    }
  }
}

PUT users/_doc/1
{
  &quot;firstName&quot;:&quot;Ruan&quot;,
  &quot;lastName&quot;:&quot;Yiming&quot;
}

POST users/_search
{
  &quot;query&quot;:{
    &quot;match&quot;:{
      &quot;fullName&quot;:{
        &quot;query&quot;:&quot;Ruan Yiming&quot;,
        &quot;operator&quot;: &quot;and&quot;
      }
    }
  }
}


# 数组类型
PUT users/_doc/1
{
  &quot;name&quot;:&quot;onebird&quot;,
  &quot;insterests&quot;:&quot;reading&quot;
}

POST users/_search
{
  &quot;query&quot;:{
    &quot;match_all&quot;: {}
  }
}

PUT users/_doc/1
{
  &quot;name&quot;:&quot;twobirds&quot;,
  &quot;insterests&quot;:[&quot;reading&quot;, &quot;music&quot;]
}

GET users/_mapping
</div></code></pre>
<h2 id="%E5%A4%9A%E5%AD%97%E6%AE%B5%E7%89%B9%E6%80%A7">多字段特性</h2>
<p>可以为一个字段增加一个子字段, 默认情况下, es会为text字段增加一个keyword字段.</p>
<ul>
<li>ExactValue
<ul>
<li>包括数字/日期/具体的一个字符串</li>
<li>对应ES中的keyword</li>
<li>精确匹配, 没有必要做分词处理</li>
</ul>
</li>
<li>FullText
<ul>
<li>全文本, 非结构化的文本数据</li>
<li>对应ES中的Text</li>
<li>需要支持模糊查询, 需要分词</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>PUT products
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;company&quot;:{
        &quot;type&quot;:&quot;text&quot;,
        &quot;fields&quot;: {
          &quot;keyword&quot;:{
            &quot;type&quot;: &quot;keyword&quot;,
            &quot;ignore_above&quot;: 256
          }
        }
      },
      &quot;comment&quot;:{
        &quot;type&quot;: &quot;text&quot;,
        &quot;fields&quot;: {
          &quot;english_comment&quot;:{
            &quot;type&quot;: &quot;text&quot;,
            &quot;analyzer&quot;: &quot;english&quot;,
            &quot;search_analyzer&quot;: &quot;english&quot;
          }
        }
      }
    }
  }
}
</div></code></pre>
<h2 id="indextemplate%E5%92%8Cdynamictemplate">IndexTemplate和DynamicTemplate</h2>
<ul>
<li>index template
<ul>
<li>作用的对象是一系列索引</li>
<li>帮助设置mappings和settings, 并按照一定的规则, 自动匹配到新创建的索引之上</li>
<li>模板仅在一个索引被新创建时, 才会产生作用. 修改模板, 不会影响已创建的索引</li>
<li>可以设定多个Index template, 这些设置会被merge到一起</li>
<li>可以指定order数值, 控制merge的过程</li>
<li>工作方式:
<ol>
<li>应用es默认的settings和mappings</li>
<li>应用order数值低的index template, 覆盖上述的</li>
<li>应用order数值高的index template, 覆盖上述的</li>
<li>应用创建索引时所指定的settings和mappings, 覆盖上述的</li>
</ol>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div># 使用es默认设置
PUT ttemplate/_doc/1
{
  &quot;someNumber&quot;: &quot;1&quot;,
  &quot;someDate&quot;: &quot;2019/01/01&quot;
}

GET ttemplate/_mapping

# 设置一个全匹配的默认template
PUT _template/template_default
{
  &quot;index_patterns&quot;: [&quot;*&quot;],
  &quot;order&quot;: 0,
  &quot;version&quot;: 1,
  &quot;settings&quot;:{
    &quot;number_of_shards&quot;:1,
    &quot;number_of_replicas&quot;: 1
  }
}

# 设置一个匹配test开头index的template, 关掉日期探测
PUT _template/template_test
{
  &quot;index_patterns&quot;: [&quot;test*&quot;],
  &quot;order&quot;: 1,
  &quot;settings&quot;: {
    &quot;number_of_shards&quot;: 1,
    &quot;number_of_replicas&quot;: 2
  },
  &quot;mappings&quot;: {
    &quot;date_detection&quot;: false,
    &quot;numeric_detection&quot;: true
  }
}

# 查看template
GET _template/template_default
GET _template/template*.kibana_task_manager

PUT testtemplate/_doc/1
{
  &quot;someNumber&quot;: &quot;1&quot;,
  &quot;someDate&quot;: &quot;2021/06/12&quot;
}

GET testtemplate/_mapping
GET testtemplate/_settings

# 索引中指定了settings
PUT testmy
{
  &quot;settings&quot;: {
    &quot;number_of_replicas&quot;: 5
  }
}

PUT testmy/_doc/1
{
  &quot;key&quot;: &quot;value&quot;
}

GET testmy/_settings
</div></code></pre>
<ul>
<li>DynamicTemplate
<ul>
<li>作用的对象是指定的索引的字段</li>
<li>结合字段名称, 动态设定字段类型</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>DELETE my_index

# 创建索引的时候, 设置dynamic template
PUT my_index
{
  &quot;mappings&quot;:{
    &quot;dynamic_templates&quot;:[
      {
        &quot;strings_as_boolean&quot;:{
          &quot;match_mapping_type&quot;:&quot;string&quot;,
          &quot;match&quot;:&quot;is*&quot;,
          &quot;mapping&quot;:{
            &quot;type&quot;:&quot;boolean&quot;
          }
        }
      },{
        &quot;string_as_keywords&quot;:{
          &quot;match_mapping_type&quot;:&quot;string&quot;,
          &quot;mapping&quot;:{
            &quot;type&quot;:&quot;keyword&quot;
          }
        }
      }
    ]
  }
}

PUT my_index/_doc/1
{
  &quot;firstName&quot;: &quot;Frog&quot;,
  &quot;isVIP&quot;: &quot;true&quot;
}

GET my_index/_mapping

DELETE my_index

# 再次演示
PUT my_index
{
  &quot;mappings&quot;: {
    &quot;dynamic_templates&quot;:[
      {
        &quot;full_name&quot;: {
          &quot;path_match&quot;: &quot;name.*&quot;,
          &quot;path_unmatch&quot;: &quot;*.middle&quot;,
          &quot;mapping&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;copy_to&quot;: &quot;full_name&quot;
          }
        }
      }
    ]
  }
}

PUT my_index/_doc/1
{
  &quot;name&quot;: {
    &quot;first&quot;: &quot;John&quot;,
    &quot;middle&quot;: &quot;Winston&quot;,
    &quot;last&quot;: &quot;Lennon&quot;
  }
}

POST my_index/_search
{
  &quot;query&quot;:{
    &quot;match&quot;: {
      &quot;full_name&quot;: &quot;John&quot;
    }
  }
}
</div></code></pre>
<h2 id="%E6%9F%A5%E8%AF%A2">查询</h2>
<ul>
<li>URI Search</li>
<li>RequestBodySearch</li>
</ul>
<pre class="hljs"><code><div># 查询
POST kibana_sample_data_ecommerce/_search
{
  &quot;_source&quot;: [&quot;customer_full_name&quot;, &quot;day_of_week&quot;], 
  &quot;sort&quot;:[{&quot;order_date&quot;:&quot;desc&quot;}],
  &quot;query&quot;:{
    &quot;match_all&quot;: {}
  },
  &quot;from&quot;:10,
  &quot;size&quot;:10
}

# 脚本字段
POST kibana_sample_data_ecommerce/_search
{
  &quot;script_fields&quot;: {
    &quot;new_field&quot;: {
      &quot;script&quot;: {
        &quot;lang&quot;:&quot;painless&quot;,
        &quot;source&quot;: &quot;doc['order_date'].value+'_hello'&quot;
      }
    }
  },
  &quot;query&quot;:{
    &quot;match_all&quot;: {}
  }
}

# match
POST movies/_search
{
  &quot;query&quot;:{
    &quot;match&quot;:{
      &quot;title&quot;:{
        // or的关系
        &quot;query&quot;:&quot;Last Christmas&quot;
      }
    }
  }
}

POST movies/_search
{
  &quot;query&quot;:{
    &quot;match&quot;:{
      &quot;title&quot;:{
        &quot;query&quot;:&quot;Last Christmas&quot;,
        &quot;operator&quot;: &quot;and&quot;
      }
    }
  }
}

POST movies/_search
{
  &quot;query&quot;:{
    &quot;match_phrase&quot;: {
      &quot;title&quot;: {
        &quot;query&quot;:&quot;one love&quot;,
        &quot;slop&quot;: 1
        // 默认严格匹配one love, 加上slop后, 允许中间存在1个其他词
      }
    }
  }
}
</div></code></pre>
<blockquote>
<p>match中terms之间是or的关系, match_phrase中terms之间是and的关系, 并且term之间位置也会影响搜索结果</p>
</blockquote>
<p><strong>term query</strong></p>
<pre class="hljs"><code><div>DELETE products

PUT products
{
  &quot;settings&quot;: {
    &quot;number_of_shards&quot;: 1
  }
}

PUT /products/_bulk
{ &quot;index&quot; : {&quot;_id&quot; : 1 } }
{ &quot;productId&quot; : &quot;XHAR-A-1234-#EI&quot;, &quot;desc&quot;: &quot;iPhone&quot;}
{ &quot;index&quot; : {&quot;_id&quot; : 2 } }
{ &quot;productId&quot; : &quot;JSDK-B-2349-#OP&quot;, &quot;desc&quot;: &quot;iPad&quot;}
{ &quot;index&quot; : {&quot;_id&quot; : 3 } }
{ &quot;productId&quot; : &quot;QWUI-C-8907-#AK&quot;, &quot;desc&quot;: &quot;MBP&quot;}

# 执行后, 可以发现, productId和desc均为text类型, 并且都存在keyword子类型
GET /products

# 查询不到任何东西, term查询, 查询条件不做任何处理, 但是, 索引的时候, 会对数据进行分词处理, 即转为小写
POST products/_search
{
  &quot;query&quot;:{
    &quot;term&quot;:{
      &quot;desc&quot;:&quot;iPhone&quot;
    }
  }
}

# 可以查询到数据
POST products/_search
{
  &quot;query&quot;:{
    &quot;term&quot;:{
      &quot;desc&quot;:&quot;iphone&quot;
    }
  }
}

# 什么也查不到, 因为索引数据时, 对productId进行了分词处理
POST products/_search
{
  &quot;query&quot;:{
    &quot;term&quot;:{
      &quot;productId&quot;: &quot;XHAR-A-1234-#EI&quot;
    }
  }
}

# 可以查到数据
POST products/_search
{
  &quot;query&quot;:{
    &quot;term&quot;:{
      &quot;productId&quot;: &quot;xhar&quot;
    }
  }
}

# 可以查询到数据
POST products/_search
{
  &quot;query&quot;:{
    &quot;term&quot;:{
      &quot;productId.keyword&quot;: &quot;XHAR-A-1234-#EI&quot;
    }
  }
}

# 跳过算分
POST products/_search
{
  &quot;query&quot;:{
    &quot;constant_score&quot;: {
      &quot;filter&quot;: {
        &quot;term&quot;:{
          &quot;productId.keyword&quot;: &quot;XHAR-A-1234-#EI&quot;
        }
      }
    }
  }
}
</div></code></pre>
<p><strong>全文本查询</strong></p>
<pre class="hljs"><code><div># 返回了包含Matrix或者reloaded的所有文档
POST movies/_search
{
  &quot;query&quot;:{
    &quot;match&quot;:{
      &quot;title&quot;:{
        &quot;query&quot;: &quot;Matrix reloaded&quot;
      }
    }
  }
}

# 对上面的查询进行精确的匹配, 这样就只返回一条了
POST movies/_search
{
  &quot;query&quot;:{
    &quot;match&quot;:{
      &quot;title&quot;:{
        &quot;query&quot;: &quot;Matrix reloaded&quot;,
        &quot;operator&quot;: &quot;AND&quot;
      }
    }
  }
}

# 对上面的查询进行精确的匹配, 指示至少匹配两个term
POST movies/_search
{
  &quot;query&quot;:{
    &quot;match&quot;:{
      &quot;title&quot;:{
        &quot;query&quot;: &quot;Matrix reloaded&quot;,
        &quot;minimum_should_match&quot;: 2
      }
    }
  }
}

# match_phrase直接就能精确查询, 因为这里默认terms之间是and
POST movies/_search
{
  &quot;query&quot;:{
    &quot;match_phrase&quot;: {
      &quot;title&quot;: {
        &quot;query&quot;: &quot;Matrix reloaded&quot;
      }
    }
  }
}

# 通过slop, 允许两个term之间存在一个其他词
POST movies/_search
{
  &quot;query&quot;:{
    &quot;match_phrase&quot;: {
      &quot;title&quot;: {
        &quot;query&quot;: &quot;Matrix reloaded&quot;,
        &quot;slop&quot;: 1
      }
    }
  }
}
</div></code></pre>
<ul>
<li>query string</li>
</ul>
<pre class="hljs"><code><div>PUT users/_doc/2
{
  &quot;name&quot;:&quot;Frog If&quot;,
  &quot;about&quot;: &quot;World&quot;
}

POST users/_search
{
  &quot;query&quot;:{
    &quot;query_string&quot;:{
      &quot;default_field&quot;: &quot;name&quot;,
      &quot;query&quot;:&quot;Frog AND IF&quot;
    }
  }
}

POST users/_search
{
  &quot;query&quot;:{
    &quot;query_string&quot;:{
      &quot;fields&quot;: [&quot;name&quot;, &quot;about&quot;],
      &quot;query&quot;: &quot;(Frog AND IF) OR World&quot;
    }
  }
}

# simple query string operator默认是or
POST users/_search
{
  &quot;query&quot;:{
    &quot;simple_query_string&quot;:{
      &quot;fields&quot;: [&quot;name&quot;],
      &quot;query&quot;:&quot;Frog AND HH&quot;
    }
  }
}

POST users/_search
{
  &quot;query&quot;:{
    &quot;simple_query_string&quot;:{
      &quot;fields&quot;: [&quot;name&quot;],
      &quot;query&quot;:&quot;Frog HH&quot;,
      &quot;default_operator&quot;: &quot;AND&quot;
    }
  }
}
</div></code></pre>
<p><strong>结构化搜索</strong></p>
<pre class="hljs"><code><div>DELETE products

POST products/_bulk
{ &quot;index&quot; : { &quot;_id&quot; : 1 }}
{ &quot;price&quot; : 10, &quot;available&quot; : true, &quot;date&quot; : &quot;2018-01-01&quot;, &quot;productId&quot; : &quot;AFDS-A-1234-#SJ&quot;}
{ &quot;index&quot; : { &quot;_id&quot; : 2 }}
{ &quot;price&quot; : 20, &quot;available&quot; : true, &quot;date&quot; : &quot;2019-01-01&quot;, &quot;productId&quot; : &quot;KDEF-B-2345-#AK&quot;}
{ &quot;index&quot; : { &quot;_id&quot; : 3 }}
{ &quot;price&quot; : 30, &quot;available&quot; : true, &quot;productId&quot; : &quot;AKDS-C-4567-#EK&quot;}
{ &quot;index&quot; : { &quot;_id&quot; : 4 }}
{ &quot;price&quot; : 40, &quot;available&quot; : true, &quot;productId&quot; : &quot;QQPX-D-4839-#IO&quot;}

# 发现都被索引为正确的类型: boolean, date, long, text
GET products/_mapping

# 对boolean值进行查询
POST products/_search
{
  &quot;query&quot;:{
    &quot;term&quot;: {
      &quot;available&quot; : {
        &quot;value&quot;: &quot;true&quot;
      }
    }
  }
}

# 跳过算分
POST products/_search
{
  &quot;query&quot;:{
    &quot;constant_score&quot;: {
      &quot;filter&quot;: {
        &quot;term&quot;: {
          &quot;available&quot; : {
            &quot;value&quot;: &quot;true&quot;
          }
        }
      }
    }
  }
}

# 数字的搜索 -- range
POST products/_search
{
  &quot;query&quot;:{
    &quot;constant_score&quot;: {
      &quot;filter&quot;: {
        &quot;range&quot;: {
          &quot;price&quot;: {
            &quot;gte&quot;: 20,
            &quot;lte&quot;: 30
          }
        }
      }
    }
  }
}

# 日期range查询
# y - 年; M - 月; w - 周; d - 天; H/h - 小时; m - 分钟; s - 秒
POST products/_search
{
  &quot;query&quot;:{
    &quot;constant_score&quot;: {
      &quot;filter&quot;: {
        &quot;range&quot;: {
          &quot;date&quot;: {
            &quot;gte&quot;: &quot;now-1y&quot;
          }
        }
      }
    }
  }
}

# 通过exists查询包含不包含, 查询存在date字段的文档
POST products/_search
{
  &quot;query&quot;:{
    &quot;constant_score&quot;: {
      &quot;filter&quot;: {
        &quot;exists&quot;: {
          &quot;field&quot;: &quot;date&quot;
        }
      }
    }
  }
}


# 处理多值字段演示数据
POST movies_kk/_bulk
{ &quot;index&quot; : { &quot;_id&quot; : 1 } }
{ &quot;title&quot; : &quot;Father of the Bridge Part II&quot;, &quot;year&quot; : 1995, &quot;genre&quot; : &quot;Comedy&quot;}
{ &quot;index&quot; : { &quot;_id&quot; : 2 } }
{ &quot;title&quot; : &quot;Dave&quot;, &quot;year&quot; : 1993, &quot;genre&quot; : [&quot;Comedy&quot;, &quot;Romance&quot;]}

GET movies_kk/_mapping

POST movies_kk/_search
{
  &quot;query&quot;:{
    &quot;term&quot;:{
      &quot;genre.keyword&quot; : &quot;Comedy&quot;
    }
  }
}
</div></code></pre>
<p><strong>聚合分析</strong></p>
<ul>
<li>分类
<ul>
<li>BucketAggregation - 一些列满足特定条件的文档集合
<ul>
<li>SQL查询是, Group By xxx, 这里的xxx就可以理解为一个bucket</li>
</ul>
</li>
<li>MetricAggregation - 一些数学运算, 可以对文档字段进行统计分析
<ul>
<li>基于数据集计算结果, 支持在字段上进行计算, 支持脚本计算</li>
<li>输出单一值: min/max/avg/sum/cardinality</li>
<li>输出多值: stats/percentiles/percentile_ranks</li>
</ul>
</li>
<li>PipelineAggregation - 对其他的聚合结果进行二次分析</li>
<li>MatrixAggregation - 支持对多个字段的操作并提供结果矩阵</li>
</ul>
</li>
</ul>
<h2 id="%E6%90%9C%E7%B4%A2%E7%9B%B8%E5%85%B3%E6%80%A7%E5%92%8C%E7%9B%B8%E5%85%B3%E6%80%A7%E7%AE%97%E5%88%86">搜索相关性和相关性算分</h2>
<p>相关性(Relevance) - 描述一个文档和查询语句匹配的程度. ES会对每个匹配查询条件的结果进行算分(_score); 打分的本质是排序, 需要把最符合用户需求的文档排在前面. ES5之前采用IF-IDF算法进行算分, 现在, 采用BM25算法.</p>
<ul>
<li>TF(Term Frequency) - 词频, 检索词在一篇文档中出现的频率
<ul>
<li>检索词出现的次数除以文档的总字数</li>
</ul>
</li>
<li>度量一条查询和结果文档相关性的简单方法: 假设有多个查询条件, 简单的将每个条件的词频相加</li>
<li>stop word, 类似'的'之类的词, 应该作为停用词, 不计入算分</li>
<li>DF(Document Frequency) - 检索词在所有文档中出现的频率</li>
<li>IDF(Inverse Document Frequency) - 通俗地说 = log(全部文档数/检索词出现过的文档总数), 检索词出现的次数越少, 越稀有, 如果匹配到, 则它在算分时权重越大</li>
<li>基本的TF-IDF算法: <code>TF(检索词1)*IDF(检索词1)+TF(检索词2)*IDF(检索词2)+...</code></li>
<li>lucene中的TF-IDF: 很复杂, 大概是这样: <code>TF(检索词1)*IDF(检索词1)*boost(检索词1)*norm(检索词1)+TF(检索词2)*IDF(检索词2)*boost(检索词2)*norm(检索词2)+...</code>
<ul>
<li>boost - 手动指定的值, 用于自定义算分提升</li>
<li>norm - 文档越短, 相关性越高</li>
</ul>
</li>
<li>BM25算法 - 解决了TF-IDF的一个问题 - 当TF无限增加时, _score会无限增长</li>
</ul>
<pre class="hljs"><code><div>PUT testscore/_bulk
{ &quot;index&quot;: {&quot;_id&quot;:1}}
{ &quot;content&quot; : &quot;we use Elasticsearch to power the search&quot; }
{ &quot;index&quot;: {&quot;_id&quot;:2}}
{ &quot;content&quot; : &quot;we like elasticsearch&quot; }
{ &quot;index&quot;: {&quot;_id&quot;:3}}
{ &quot;content&quot; : &quot;The scoring of documents is caculated by the socring formula&quot; }
{ &quot;index&quot;: {&quot;_id&quot;:4}}
{ &quot;content&quot; : &quot;you know, for search&quot; }

# 加入explain, 可以显示查询过程中的算分, 这里文档2短, 所以文档2算分高
POST testscore/_search
{
  &quot;explain&quot;: true,
  &quot;query&quot;:{
    &quot;match&quot;:{
      &quot;content&quot; : &quot;elasticsearch&quot;
    }
  }
}

# 通过boost影响算分结果, 由于存在like, 原来应该分数更高的doc反倒降低了
POST testscore/_search
{
  &quot;query&quot;:{
    &quot;boosting&quot;: {
      &quot;positive&quot;: {
        &quot;term&quot;:{
          &quot;content&quot;: &quot;elasticsearch&quot;
        }
      },
      &quot;negative&quot;: {
        &quot;term&quot;:{
          &quot;content&quot;: &quot;like&quot;
        }
      },
      &quot;negative_boost&quot;: 0.2
    }
  }
}
</div></code></pre>
<p><strong>多字段查询</strong></p>
<ul>
<li>bool查询
<ul>
<li>支持四种子句:
<ul>
<li>must: 必须匹配, 贡献算分</li>
<li>should: 选择性匹配, 贡献算分</li>
<li>must_not: 必须不包含, 不贡献算分</li>
<li>filter: 必须匹配, 不贡献算分</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>POST products/_search
{
  &quot;query&quot;:{
    &quot;bool&quot;: {
      &quot;must&quot;:[
        {
          &quot;term&quot;:{
            &quot;price&quot;: &quot;30&quot;
          }
        }
      ],
      &quot;filter&quot;:[
        {
          &quot;term&quot;:{
            &quot;available&quot;: &quot;true&quot;
          }
        }
      ],
      &quot;must_not&quot;:[
        {
          &quot;range&quot;:{
            &quot;price&quot;:{
              &quot;lte&quot;: 10
            }
          }
        }
      ],
      &quot;should&quot;: [
        { 
          &quot;term&quot; : { 
            &quot;productId.keyword&quot;: &quot;AKDS-C-4567-#EK&quot;
          } 
        },
        {
          &quot;term&quot; : {
            &quot;productId.keyword&quot;: &quot;sfjkasjflsjklfj&quot;
          }
        }
      ]
    }
  }
}


POST newmovies/_bulk
{ &quot;index&quot;: { &quot;_id&quot; : 1 } }
{ &quot;title&quot;: &quot;Father of the Bridge Part II&quot;, &quot;year&quot; : 1995, &quot;genre&quot; : &quot;Comedy&quot;, &quot;genre_count&quot; : 1 }
{ &quot;index&quot;: { &quot;_id&quot; : 2 } }
{ &quot;title&quot;: &quot;Dave&quot;, &quot;year&quot; : 1993, &quot;genre&quot; : [&quot;Comedy&quot;, &quot;Romance&quot;], &quot;genre_count&quot; : 2 }

# 精确查询只有Comedy的
POST newmovies/_search
{
  &quot;query&quot;:{
    &quot;bool&quot;:{
      &quot;must&quot;:[
        {
          &quot;term&quot; : {
            &quot;genre.keyword&quot; : &quot;Comedy&quot;
          }
        },{
          &quot;term&quot; : {
            &quot;genre_count&quot; : 1
          }
        }
      ]
    }
  }
}

# 同上, 同时不算分
POST newmovies/_search
{
  &quot;query&quot;:{
    &quot;bool&quot;:{
      &quot;filter&quot;:[
        {
          &quot;term&quot; : {
            &quot;genre.keyword&quot; : &quot;Comedy&quot;
          }
        },{
          &quot;term&quot; : {
            &quot;genre_count&quot; : 1
          }
        }
      ]
    }
  }
}

# bool嵌套
POST products/_search
{
  &quot;query&quot;:{
    &quot;bool&quot;: {
      &quot;must&quot;:{
        &quot;term&quot;:{
          &quot;price&quot; : 30
        }
      },
      &quot;should&quot;: [
        {
          &quot;bool&quot;: {
            &quot;must_not&quot;: [
              {
                &quot;term&quot;: {
                  &quot;available&quot;: {
                    &quot;value&quot;: &quot;false&quot;
                  }
                }
              }
            ]
          }
        }
      ]
    }
  }
}

# 嵌套中, 同一级具有相同的权重, 通过嵌套bool, 可以改变算分的结果
POST animals/_bulk
{ &quot;index&quot; : { &quot;_id&quot; : 1 } }
{ &quot;text&quot; : &quot;there are a red dog, run very fast.&quot;}
{ &quot;index&quot; : { &quot;_id&quot; : 2 } }
{ &quot;text&quot; : &quot;there are a brown dog, run very slow.&quot;}
{ &quot;index&quot; : { &quot;_id&quot; : 3 } }
{ &quot;text&quot; : &quot;there are a brown cat.&quot;}

POST animals/_search
{
  &quot;query&quot;:{
    &quot;bool&quot;: {
      &quot;should&quot;: [
        { &quot;term&quot; : { &quot;text&quot;: &quot;brown&quot; } },
        { &quot;term&quot; : { &quot;text&quot;: &quot;red&quot; } },
        { &quot;term&quot; : { &quot;text&quot;: &quot;fast&quot; } },
        { &quot;term&quot; : { &quot;text&quot;: &quot;dog&quot; } }
      ]
    }
  }
}

POST animals/_search
{
  &quot;query&quot;:{
    &quot;bool&quot;: {
      &quot;should&quot;: [
        { &quot;term&quot; : { &quot;text&quot;: &quot;fast&quot; } },
        { &quot;term&quot; : { &quot;text&quot;: &quot;dog&quot; } },
        {
          &quot;bool&quot;: {
            &quot;should&quot;: [
                { &quot;term&quot; : { &quot;text&quot;: &quot;brown&quot; } },
                { &quot;term&quot; : { &quot;text&quot;: &quot;red&quot; } }
            ]
          }
        }
      ]
    }
  }
}

# 通过boost影响算分的演示
POST blogs/_bulk
{ &quot;index&quot; : { &quot;_id&quot; : 1 } }
{ &quot;title&quot; : &quot;Apple iPad&quot;, &quot;content&quot; : &quot;Apple iPad, Apple iPad&quot; }
{ &quot;index&quot; : { &quot;_id&quot; : 2 } }
{ &quot;title&quot; : &quot;Apple iPad, Apple iPad&quot;, &quot;content&quot; : &quot;Apple iPad&quot; }

POST blogs/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;should&quot;: [
        {
          &quot;match&quot;: {
            &quot;title&quot;: {
              &quot;query&quot;: &quot;apple, ipad&quot;,
              &quot;boost&quot;: 1.1
            }
          }
        },
        {
          &quot;match&quot;: {
            &quot;content&quot;: {
              &quot;query&quot; : &quot;apple, ipad&quot;,
              &quot;boost&quot;: 1
            }
          }
        }
      ]
    }
  }
}

POST blogs/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;should&quot;: [
        {
          &quot;match&quot;: {
            &quot;title&quot;: {
              &quot;query&quot;: &quot;apple, ipad&quot;,
              &quot;boost&quot;: 1.1
            }
          }
        },
        {
          &quot;match&quot;: {
            &quot;content&quot;: {
              &quot;query&quot; : &quot;apple, ipad&quot;,
              &quot;boost&quot;: 2
            }
          }
        }
      ]
    }
  }
}

# 查询, 要求苹果公司的产品优先
POST news/_bulk
{ &quot;index&quot; : { &quot;_id&quot; : 1 } }
{ &quot;content&quot; : &quot;Apple Mac&quot; }
{ &quot;index&quot; : { &quot;_id&quot; : 2 } }
{ &quot;content&quot; : &quot;Apple iPad&quot; }
{ &quot;index&quot; : { &quot;_id&quot; : 3 } }
{ &quot;content&quot; : &quot;Apple Employee like Apple Pie and Apple Juice&quot; }

POST news/_search
{
  &quot;query&quot;:{
    &quot;match&quot;: {
      &quot;content&quot;: &quot;apple&quot;
    }
  }
}

POST news/_search
{
  &quot;query&quot;:{
    &quot;bool&quot;: {
      &quot;must&quot;: [
        {
          &quot;match&quot;: {
            &quot;content&quot;: &quot;apple&quot;
          }
        }
      ],
      &quot;must_not&quot;: [
        {
          &quot;match&quot;: {
            &quot;content&quot;: &quot;pie&quot;
          }
        }
      ]
    }
  }
}

# pie依旧能查询出来, 但是排在最后
POST news/_search
{
  &quot;query&quot;:{
    &quot;boosting&quot;: {
      &quot;positive&quot;: {
        &quot;match&quot;: {
          &quot;content&quot;: &quot;apple&quot;
        }
      },
      &quot;negative&quot;: {
        &quot;match&quot;: {
          &quot;content&quot;: &quot;pie&quot;
        }
      },
      &quot;negative_boost&quot;: 0.5
    }
  }
}
</div></code></pre>
<p><strong>单字符串多字段查询</strong></p>
<ul>
<li>Disjunction Max Query</li>
</ul>
<pre class="hljs"><code><div>PUT blogs/_bulk
{ &quot;index&quot; : { &quot;_id&quot; : 1 } }
{ &quot;title&quot; : &quot;Quick brown rabbits&quot;, &quot;body&quot; : &quot;Brown rabbits are commonly seen.&quot; }
{ &quot;index&quot; : { &quot;_id&quot; : 2} }
{ &quot;title&quot; : &quot;Keeping pets healthy&quot;, &quot;body&quot; : &quot;My quick brown fox eats rabbits on a regular basis.&quot; }

# 这样查询出来的, 1算分更高, 但是显然2更符合需求, 这是因为should查询, 会将多个子查询的算分结果相加, 导致算分不符合预期
POST blogs/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;:{
      &quot;should&quot;: [
        {
          &quot;match&quot;: {
            &quot;title&quot;: &quot;Brown fox&quot;
          }
        },
        {
          &quot;match&quot;: {
            &quot;body&quot;: &quot;Brown fox&quot;
          }
        }
      ]
    }
  }
}

# 使用disjunction max query, 采用字段上算分的最大值作为最终评分, 而不是加和
POST blogs/_search
{
  &quot;query&quot;: {
    &quot;dis_max&quot;:{
      &quot;queries&quot;: [
        {
          &quot;match&quot;: {
            &quot;title&quot;: &quot;Brown fox&quot;
          }
        },
        {
          &quot;match&quot;: {
            &quot;body&quot;: &quot;Brown fox&quot;
          }
        }
      ]
    }
  }
}

# 执行结果中, 两篇文档的算分相同, 虽然文档2中既有pets又有quick
POST blogs/_search
{
  &quot;query&quot;: {
    &quot;dis_max&quot;:{
      &quot;queries&quot;: [
        {
          &quot;match&quot;: {
            &quot;title&quot;: &quot;quick pets&quot;
          }
        },
        {
          &quot;match&quot;: {
            &quot;body&quot;: &quot;quick pets&quot;
          }
        }
      ]
    }
  }
}

# tie_breaker的作用: max(_score) + _other_score * tie_breaker, 最终使得文档2的算分更高
POST blogs/_search
{
  &quot;query&quot;: {
    &quot;dis_max&quot;:{
      &quot;queries&quot;: [
        {
          &quot;match&quot;: {
            &quot;title&quot;: &quot;quick pets&quot;
          }
        },
        {
          &quot;match&quot;: {
            &quot;body&quot;: &quot;quick pets&quot;
          }
        }
      ],
      &quot;tie_breaker&quot;: 0.1
    }
  }
}
</div></code></pre>
<p><strong>Multi Match</strong></p>
<p>单字符串多字段搜索的三种场景:</p>
<ul>
<li>最佳字段(Best Fields): 字段之间互相竞争, 有互相关联. 评分来自最高分字段.</li>
<li>多数字段(Most Fields): 匹配的字段越多越好</li>
<li>混合字段(Cross Field): 单字段作为整体的一部分, 希望在任何这些列出的字段中, 找到尽可能多的词</li>
</ul>
<pre class="hljs"><code><div># 用multi match实现dis_max相同的功能
POST blogs/_search
{
  &quot;query&quot;:{
    &quot;multi_match&quot;: {
      &quot;type&quot;: &quot;best_fields&quot;, 
      &quot;query&quot;: &quot;quick pets&quot;,
      &quot;fields&quot;: [&quot;title&quot;, &quot;body&quot;],
      &quot;tie_breaker&quot;: 0.2,
      &quot;minimum_should_match&quot;: &quot;20%&quot;
    }
  }
}

PUT titles
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;title&quot;:{
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;english&quot;
      }
    }
  }
}

POST titles/_bulk
{ &quot;index&quot; : { &quot;_id&quot; : 1 } }
{ &quot;title&quot; : &quot;My dogs barks&quot; }
{ &quot;index&quot; : { &quot;_id&quot; : 2 } }
{ &quot;title&quot; : &quot;I see a lot of barking dogs on the road.&quot; }

# 预期第二篇文档的算分更高, 实际结果是第一篇文档算分更高, 这是因为第一个文档更短, 权重更高, 算分也就更高
POST titles/_search
{
  &quot;query&quot; : {
    &quot;match&quot;: {
      &quot;title&quot;: &quot;barking dogs&quot;
    }
  }
}

DELETE titles

# english分词器, 会对单词进行处理, 比如时态, 单数复数等, standard分词器, 不会做这些处理
PUT titles
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;title&quot;:{
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;english&quot;,
        &quot;fields&quot;: {
          &quot;std&quot; : {
            &quot;type&quot; : &quot;text&quot;,
            &quot;analyzer&quot; : &quot;standard&quot;
          }
        }
      }
    }
  }
}

POST _analyze
{
  &quot;analyzer&quot;: &quot;english&quot;,
  &quot;text&quot;: [
    &quot;My dogs barks&quot;,
    &quot;I see a lot of barking dogs on the road.&quot;
  ]
}

POST titles/_bulk
{ &quot;index&quot; : { &quot;_id&quot; : 1 } }
{ &quot;title&quot; : &quot;My dogs barks&quot; }
{ &quot;index&quot; : { &quot;_id&quot; : 2 } }
{ &quot;title&quot; : &quot;I see a lot of barking dogs on the road.&quot; }


# 匹配尽可能多的字段, 这时, 记录2的算分高于1
POST titles/_search
{
  &quot;query&quot;:{
    &quot;multi_match&quot;: {
      &quot;query&quot;: &quot;barking dogs&quot;,
      &quot;fields&quot;: [&quot;title&quot;, &quot;title.std&quot;],
      &quot;type&quot;: &quot;most_fields&quot;
    }
  }
}

PUT address/_doc/1
{
  &quot;street&quot;: &quot;5 Poland Street&quot;,
  &quot;city&quot; : &quot;London&quot;,
  &quot;country&quot; : &quot;United Kingdom&quot;,
  &quot;postcode&quot; : &quot;M1V 3DG&quot;
}

# 当要求查询的term全部都需要出现在这几个字段上时, 这样搜索是搜不到的
POST address/_search
{
  &quot;query&quot;:{
    &quot;multi_match&quot;: {
      &quot;query&quot;: &quot;Poland Street M1V&quot;,
      &quot;fields&quot;: [&quot;street&quot;, &quot;city&quot;, &quot;country&quot;, &quot;postcode&quot;],
      &quot;type&quot;: &quot;most_fields&quot;,
      &quot;operator&quot;: &quot;and&quot;
    }
  }
}

# 使用cross fields就可以了
POST address/_search
{
  &quot;query&quot;:{
    &quot;multi_match&quot;: {
      &quot;query&quot;: &quot;Poland Street M1V&quot;,
      &quot;fields&quot;: [&quot;street&quot;, &quot;city&quot;, &quot;country&quot;, &quot;postcode&quot;],
      &quot;type&quot;: &quot;cross_fields&quot;,
      &quot;operator&quot;: &quot;and&quot;
    }
  }
}
</div></code></pre>
<p><strong>SearchTemplate</strong></p>
<p>用于解耦程序和DSL</p>
<pre class="hljs"><code><div># 定义一个search template搜索模板
POST _scripts/tmdb
{
  &quot;script&quot;:{
      &quot;lang&quot;: &quot;mustache&quot;,
      &quot;source&quot;: {
        &quot;_source&quot;:[ &quot;title^2&quot;, &quot;overview&quot; ],
        &quot;size&quot;: 20,
        &quot;query&quot;: {
          &quot;multi_match&quot;: {
            &quot;query&quot;: &quot;{{q}}&quot;,
            &quot;fields&quot;: [&quot;title&quot;, &quot;overview&quot;]
          }
        }
      }
  }
}

GET _scripts/tmdb

# 使用search template
POST tmdb/_search/template
{
  &quot;id&quot;: &quot;tmdb&quot;,
  &quot;params&quot;: {
    &quot;q&quot;: &quot;basketball with cartoon aliens&quot;
  }
}
</div></code></pre>
<p><strong>Index Alias</strong></p>
<p>索引的别名</p>
<pre class="hljs"><code><div>PUT movies-2019/_doc/1
{
  &quot;name&quot;:&quot;the matrix&quot;,
  &quot;rating&quot;:5
}

PUT movies-2019/_doc/2
{
  &quot;name&quot;:&quot;Speed&quot;,
  &quot;rating&quot;:3
}

# 对索引起别名
POST _aliases
{
  &quot;actions&quot;: [
    {
      &quot;add&quot;: {
        &quot;index&quot;: &quot;movies-2019&quot;,
        &quot;alias&quot;: &quot;movies-latest&quot;
      }
    }
  ]
}

POST movies-latest/_search
{
  &quot;query&quot;: {
    &quot;match_all&quot;: {}
  }
}

# 定义新的别名, 只返回rating大于4的数据
POST _aliases
{
  &quot;actions&quot;: [
    {
      &quot;add&quot;: {
        &quot;index&quot;: &quot;movies-2019&quot;,
        &quot;alias&quot;: &quot;movies-latest-highrate&quot;,
        &quot;filter&quot;: {
          &quot;range&quot;: {
            &quot;rating&quot;: {
              &quot;gte&quot;: 4
            }
          }
        }
      }
    }
  ]
}

POST movies-latest-highrate/_search
{
  &quot;query&quot;: {
    &quot;match_all&quot;: {}
  }
}
</div></code></pre>
<p><strong>Function Score Query</strong></p>
<p>在查询结束后, 对每一个匹配的文档进行一系列的重新算分, 根据新生成的分数进行排序.</p>
<p>提供的几种默认的计算分值的函数:</p>
<ul>
<li>Weight: 为每篇文档设置一个简单而不被规范化的权重</li>
<li>Field Value Factor: 使用该数值来修改_score, 例如将&quot;热度&quot;和&quot;点赞数&quot;作为算分的参考因素</li>
<li>Random Score: 为每一个用户使用不同的, 随机算分结果</li>
<li>衰减函数: 以某个字段的值为标准, 距离某个值越近, 得分越高</li>
<li>Script Score: 自定义脚本完全控制所需逻辑</li>
</ul>
<p>使用Boost Mode</p>
<ul>
<li>Multiply: 算分与函数值的乘积</li>
<li>Sum: 算分与函数的和</li>
<li>Min/Max: 算分与函数取 最小/最大值</li>
<li>Replace: 使用函数值取代算分</li>
</ul>
<p>Max Boost可以将算分控制在一个最大值</p>
<p>一致性随机函数: 每个用户可以看到不同的随机排名, 但是希望同一个用户访问时, 顺序保持不变</p>
<pre class="hljs"><code><div>DELETE blogs
PUT /blogs/_doc/1
{
  &quot;title&quot;:   &quot;About popularity&quot;,
  &quot;content&quot;: &quot;In this post we will talk about...&quot;,
  &quot;votes&quot;:   0
}

PUT /blogs/_doc/2
{
  &quot;title&quot;:   &quot;About popularity&quot;,
  &quot;content&quot;: &quot;In this post we will talk about...&quot;,
  &quot;votes&quot;:   100
}

PUT /blogs/_doc/3
{
  &quot;title&quot;:   &quot;About popularity&quot;,
  &quot;content&quot;: &quot;In this post we will talk about...&quot;,
  &quot;votes&quot;:   1000000
}

# 新的算分 = 老的算分 * 投票数
POST /blogs/_search
{
  &quot;query&quot;: {
    &quot;function_score&quot;: {
      &quot;query&quot;: {
        &quot;multi_match&quot;: {
          &quot;query&quot;: &quot;popularity&quot;,
          &quot;fields&quot;: [&quot;title&quot;, &quot;content&quot;]
        }
      },
      &quot;field_value_factor&quot;: {
        &quot;field&quot;: &quot;votes&quot;
      }
    }
  }
}

# 新的算分 = 老的算分 * log(1 + 投票数)
POST /blogs/_search
{
  &quot;query&quot;: {
    &quot;function_score&quot;: {
      &quot;query&quot;: {
        &quot;multi_match&quot;: {
          &quot;query&quot;: &quot;popularity&quot;,
          &quot;fields&quot;: [&quot;title&quot;, &quot;content&quot;]
        }
      },
      &quot;field_value_factor&quot;: {
        &quot;field&quot;: &quot;votes&quot;,
        &quot;modifier&quot;: &quot;log1p&quot;
      }
    }
  }
}

# 新的算分 = 老的算分 * log(1 + factor * 投票数)
POST /blogs/_search
{
  &quot;query&quot;: {
    &quot;function_score&quot;: {
      &quot;query&quot;: {
        &quot;multi_match&quot;: {
          &quot;query&quot;: &quot;popularity&quot;,
          &quot;fields&quot;: [&quot;title&quot;, &quot;content&quot;]
        }
      },
      &quot;field_value_factor&quot;: {
        &quot;field&quot;: &quot;votes&quot;,
        &quot;modifier&quot;: &quot;log1p&quot;,
        &quot;factor&quot;: 0.1
      }
    }
  }
}

# 新的算分 = 老的算分 + log(1 + factor * 投票数)
# boost_mode默认是multiply, 就是上面的结果
POST /blogs/_search
{
  &quot;query&quot;: {
    &quot;function_score&quot;: {
      &quot;query&quot;: {
        &quot;multi_match&quot;: {
          &quot;query&quot;: &quot;popularity&quot;,
          &quot;fields&quot;: [&quot;title&quot;, &quot;content&quot;]
        }
      },
      &quot;field_value_factor&quot;: {
        &quot;field&quot;: &quot;votes&quot;,
        &quot;modifier&quot;: &quot;log1p&quot;,
        &quot;factor&quot;: 0.1
      },
      &quot;boost_mode&quot;: &quot;sum&quot;,
      &quot;max_boost&quot;: 3
    }
  }
}

# 一致性随机函数
POST /blogs/_search
{
  &quot;query&quot;:{
    &quot;function_score&quot;: {
      &quot;random_score&quot;:{
        &quot;seed&quot;: 314159265359
      }
    }
  }
}
</div></code></pre>
<p><strong>ElasticSearch Suggest API</strong></p>
<p>ElasticSearch提供的联想词功能, 原理: 将输入的文本分解为token, 然后在索引中找到相似的term返回</p>
<p>共分为四种:</p>
<ul>
<li>
<p>Term Suggester</p>
</li>
<li>
<p>Phrase Suggester</p>
</li>
<li>
<p>Complete Suggester</p>
</li>
<li>
<p>Context Suggester</p>
</li>
<li>
<p>Term Suggester(算法: 编辑距离)</p>
<ul>
<li>几种suggest mode
<ul>
<li>missing - 如果索引已经存在, 就不提供建议</li>
<li>popular - 推荐出现频率更加高的词</li>
<li>always - 无论是否存在, 都提供建议</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Phrase Suggester</p>
<ul>
<li>和term suggester类似</li>
</ul>
</li>
<li>
<p>Complete Suggester</p>
<ul>
<li>自动完成, 速度较上两种要快, 将analyze数据编码成FST和索引放在一起, 整个加载进内存</li>
<li>只适用于前缀查找</li>
</ul>
</li>
<li>
<p>Context Suggester</p>
<ul>
<li>对Complete Suggester的扩展</li>
<li>根据上下文进行搜索(Context)</li>
<li>两种Context
<ul>
<li>Category - 任意字符串</li>
<li>Geo - 地理位置</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>精准度和召回率:</p>
<ul>
<li>精准度: completion &gt; phrase &gt; term</li>
<li>召回率: term &gt; phrase &gt; completion</li>
<li>性能: completion &gt; phrase &gt; term</li>
</ul>
<pre class="hljs"><code><div>DELETE articles

POST articles/_bulk
{ &quot;index&quot; : {} }
{ &quot;body&quot; : &quot;lucene is very cool&quot; }
{ &quot;index&quot; : {} }
{ &quot;body&quot; : &quot;ElasticSearch build on top of lucene&quot; }
{ &quot;index&quot; : {} }
{ &quot;body&quot; : &quot;elastic is the company behind ELK stack&quot; }
{ &quot;index&quot; : {} }
{ &quot;body&quot; : &quot;ELK stack rocks&quot; }
{ &quot;index&quot; : {} }
{ &quot;body&quot; : &quot;elasticsearch is rock solid&quot; }

# 使用搜索建议, 只能查出lucene的推荐, 没有rock的推荐, 这是因为mode为missing, 只有不存在, 才会提供推荐
POST /articles/_search
{
  &quot;query&quot;:{
    &quot;match&quot;: {
      &quot;body&quot;: &quot;lucen rock&quot;
    }
  },
  &quot;suggest&quot;: {
    &quot;term-suggestion&quot;: {
      &quot;text&quot;: &quot;lucen rock&quot;,
      &quot;term&quot;: {
        &quot;suggest_mode&quot;: &quot;missing&quot;,
        &quot;field&quot;: &quot;body&quot;
      }
    }
  }
}

# prefix_length只是匹配的前缀长度, 默认是1, 设置为0就可以匹配出rock了
POST /articles/_search
{
  &quot;suggest&quot;: {
    &quot;term-suggestion&quot;: {
      &quot;text&quot;: &quot;lucen hock&quot;,
      &quot;term&quot;: {
        &quot;suggest_mode&quot;: &quot;always&quot;,
        &quot;field&quot;: &quot;body&quot;,
        &quot;sort&quot;: &quot;frequency&quot;,
        &quot;prefix_length&quot;: 0
      }
    }
  }
} 

POST articles/_search
{
  &quot;suggest&quot;: {
    &quot;my-suggestion&quot;: {
      &quot;text&quot;: &quot;lucne and elasticsear rock hello world&quot;,
      &quot;phrase&quot;: {
        &quot;field&quot;: &quot;body&quot;,
        &quot;max_errors&quot;: 2,
        &quot;confidence&quot;: 0,
        &quot;direct_generator&quot;:[
          {
            &quot;field&quot;: &quot;body&quot;,
            &quot;suggest_mode&quot;: &quot;always&quot;
          }
        ],
        &quot;highlight&quot;: {
          &quot;pre_tag&quot;: &quot;&lt;em&gt;&quot;,
          &quot;post_tag&quot;: &quot;&lt;/em&gt;&quot;
        }
      }
    }
  }
}
</div></code></pre>
<p>自动补全:</p>
<pre class="hljs"><code><div>DELETE articles

PUT articles
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;title_completion&quot;:{
        &quot;type&quot;: &quot;completion&quot;
      }
    }
  }
}

POST articles/_bulk
{ &quot;index&quot; : { } }
{ &quot;title_completion&quot; : &quot;lucene is very cool&quot; }
{ &quot;index&quot; : { } }
{ &quot;title_completion&quot; : &quot;Elasticsearch builds on top of lucene&quot; }
{ &quot;index&quot; : { } }
{ &quot;title_completion&quot; : &quot;Elasticsearch rocks&quot; }
{ &quot;index&quot; : { } }
{ &quot;title_completion&quot; : &quot;elastic is the company behind ELK stack&quot; }
{ &quot;index&quot; : { } }
{ &quot;title_completion&quot; : &quot;ELK stack rocks&quot; }

POST articles/_search?pretty
{
  &quot;size&quot;: 0,
  &quot;suggest&quot;: {
    &quot;article-suggester&quot;: {
      &quot;prefix&quot;: &quot;elk&quot;,
      &quot;completion&quot;: {
        &quot;field&quot;: &quot;title_completion&quot;
      }
    }
  }
}


PUT comments
PUT comments/_mapping
{
 &quot;properties&quot;: {
   &quot;comment_autocomplete&quot;:{
     &quot;type&quot;: &quot;completion&quot;,
     &quot;contexts&quot;:[
       {
         &quot;type&quot;: &quot;category&quot;,
         &quot;name&quot;: &quot;comment_category&quot;
       }
    ]
   }
 }
}

POST comments/_doc
{
  &quot;comment&quot; : &quot;I love the star war movies&quot;,
  &quot;comment_autocomplete&quot;: {
    &quot;input&quot; : [&quot;star wars&quot;],
    &quot;contexts&quot;:{
      &quot;comment_category&quot;: &quot;movies&quot;
    }
  }
}


POST comments/_doc
{
  &quot;comment&quot; : &quot;Where can I find a Starbucks&quot;,
  &quot;comment_autocomplete&quot;: {
    &quot;input&quot;: [&quot;starbucks&quot;],
    &quot;contexts&quot; : {
      &quot;comment_category&quot;: &quot;coffee&quot;
    }
  }
}

POST comments/_search
{
  &quot;suggest&quot;: {
    &quot;YOUR_SUGGESTION&quot;: {
      &quot;prefix&quot;: &quot;sta&quot;,
      &quot;completion&quot;: {
        &quot;field&quot;: &quot;comment_autocomplete&quot;,
        &quot;contexts&quot;:{
          &quot;comment_category&quot;: &quot;movies&quot;
        }
      }
    }
  }
}
</div></code></pre>
<h2 id="%E5%A4%9A%E8%AF%AD%E8%A8%80%E5%8F%8A%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D">多语言及中文分词</h2>
<ul>
<li>HanLp分词器:</li>
</ul>
<pre class="hljs"><code><div>./elasticsearch-plugin install https://github.com/KennFalcon/elasticsearch-analysis-hanlp/releases/download/v7.1.0/elasticsearch-analysis-hanlp-7.1.0.zip
</div></code></pre>
<ul>
<li>IK分词器</li>
</ul>
<pre class="hljs"><code><div>./elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.1.0/elasticsearch-analysis-ik-7.1.0.zip
</div></code></pre>
<ul>
<li>Pinyin</li>
</ul>
<pre class="hljs"><code><div>./elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-pinyin/releases/download/v7.1.0/elasticsearch-analysis-pinyin-7.1.0.zip
</div></code></pre>
<ul>
<li>ICU</li>
</ul>
<pre class="hljs"><code><div>./elasticsearch-plugin install https://github.com/elastic/elasticsearch-analysis-icu/archive/refs/tags/v2.7.0.zip
</div></code></pre>
<blockquote>
<p>通过./bin/elasticsearch-plugin list查看已安装的分词器, 分词器安装完成之后, 需要重启生效</p>
</blockquote>
<pre class="hljs"><code><div># hanlp: hanlp默认分词器
# hanlp_standard: 标准分词器
# hanlp_index: 索引分词器
# hanlp_nlp: NLP分词器
# hanlp_n_short: N-最短路径分词器
# hanlp_dijkstra: 最短路径分词器
# hanlp_crf: CRF分词器(1.6.6之后已弃用)
# hanlp_speed: 极速分词器
POST _analyze
{
  &quot;analyzer&quot;: &quot;hanlp_nlp&quot;,
  &quot;text&quot;: &quot;剑桥分析公司多位高管对卧底记者说, 他们确保了唐纳德·特朗普在总统大选中获胜&quot;
}

# Pinyin
PUT /artists/
{
  &quot;settings&quot;: {
    &quot;analysis&quot;: {
      &quot;analyzer&quot;: {
        &quot;user_name_analyzer&quot;:{
          &quot;tokenizer&quot;: &quot;whitespace&quot;,
          &quot;filter&quot;: &quot;pinyin_first_letter_and_full_pinyin_filter&quot;
        }
      },
      &quot;filter&quot;: {
        &quot;pinyin_first_letter_and_full_pinyin_filter&quot;:{
          &quot;type&quot;: &quot;pinyin&quot;,
          &quot;keep_first_letter&quot;: true,
          &quot;keep_full_pinyin&quot;: false,
          &quot;keep_original&quot;: true,
          &quot;keep_none_chinese&quot;: true,
          &quot;limit_first_letter_length&quot;: 16,
          &quot;lowercase&quot;: true,
          &quot;trim_whitespace&quot;: true,
          &quot;keep_none_chinese_in_first_letter&quot;: true
        }
      }
    }
  }
}

GET /artists/_analyze
{
  &quot;text&quot;: [&quot;刘德华 张学友 郭富城 黎明 四大天王&quot;],
  &quot;analyzer&quot;: &quot;user_name_analyzer&quot;
}
</div></code></pre>

</body>
</html>
